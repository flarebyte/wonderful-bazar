'use strict'
init = require("fb-custom-init")
sql = require('magma-sql-builder')
should = require('should')
CT = require('magma-constant')
_ = require('lodash')

PIVOT=1000000000000
PAD=15

simpleModel=
  __meta:
    domain:         "user"
    recordType:     CT.TYPE_USER_ID
    idLength:       CT.LEN_USER_ID
    pkGenerator:    ()->"pk33"

myself=
  ownerRef:         CT.EX_OWNER_U1
  gateId:           CT.EX_GATE_ID
  ownerRefs:        [CT.EX_OWNER_U1,CT.EX_OWNER_U2]

userCtx=
  my: myself
  model: simpleModel

###
======== A Handy Little Mocha Reference ========
https://github.com/visionmedia/should.js
https://github.com/visionmedia/mocha
###


describe 'magma-sql-builder', ()->
  describe '#equal', ()->
    it 'should manage equalString comparison', ()->
      sql.equalString("c7","k27").should.eql "c7='k27'"

    it 'should manage equalBool comparison', ()->
      sql.equalBool("c7","true").should.eql "c7='T'"

    it 'should manage equalInt comparison', ()->
      sql.equalInt("c7",10).should.eql "idx.int.c7='001000000000010'"

    it 'should manage equalFloat comparison', ()->
      sql.equalFloat("c7",10.4).should.eql "idx.float.c7='001000000000010.4'"

    it 'should manage equalSound comparison', ()->
      expected= "(idx.metaphone.c7='BTFL' AND "+
      "idx.metaphone.c7='IS' AND "+
      "idx.metaphone.c7='LF')"
      sql.equalSound("c7","life is beautiful").should.eql expected
 
    it 'should manage equalStem comparison', ()->
      expected= "(idx.stem.c7='beauti' AND "+
      "idx.stem.c7='life')"
      sql.equalStem("c7","life is beautiful").should.eql expected

  describe 'Time related', ()->
    tim = CT.EX_ISO_DATETIME
    it 'should manage equalDate comparison', ()->
      sql.equalDate("c7",tim).should.eql "idx.date.c7='2013-06-13'"

    it 'should manage equalYearMonth comparison', ()->
      sql.equalYearMonth("c7",tim).should.eql "idx.yearmonth.c7='2013-06'"

    it 'should manage equalYearMonth comparison', ()->
      sql.equalDayOfWeek("c7",tim).should.eql "idx.dayofweek.c7='4'"

    it 'should manage equalTime comparison', ()->
      sql.equalTime("c7",tim).should.eql "idx.time.c7='01:32:45'"

    it 'should manage equalHour comparison', ()->
      sql.equalHour("c7",tim).should.eql "idx.hour.c7='01'"

  describe 'Different', ()->
    it 'should manage notEqualString comparison', ()->
      sql.notEqualString("c7","k27").should.eql "c7!='k27'"

    it 'should manage notEqualBool comparison', ()->
      sql.notEqualBool("c7","true").should.eql "c7!='T'"

    it 'should manage notEqualInt comparison', ()->
      sql.notEqualInt("c7",10).should.eql "idx.int.c7!='001000000000010'"

    it 'should manage notEqualFloat comparison', ()->
      sql.notEqualFloat("c7",10.4).should.eql
      "idx.float.c7!='001000000000010.4'"

    it 'should manage notEqualSound comparison', ()->
      expected= "NOT (idx.metaphone.c7='BTFL' AND "+
      "idx.metaphone.c7='IS' AND "+
      "idx.metaphone.c7='LF')"
      sql.notEqualSound("c7","life is beautiful").should.eql expected

    it 'should manage notEqualStem comparison', ()->
      expected= "NOT (idx.stem.c7='beauti' AND "+
      "idx.stem.c7='life')"
      sql.notEqualStem("c7","life is beautiful").should.eql expected

  describe '#like', ()->
    it 'should manage beginWithString comparison', ()->
      sql.beginWithString("c7","k27").should.eql "c7 like 'k27%'"

    it 'should manage endWithString comparison', ()->
      sql.endWithString("c7","k27").should.eql "c7 like '%k27'"

  describe '#is or is not', ()->

    it 'should manage isNullString comparison', ()->
      sql.isNullString("c7","k27").should.eql "c7 is null"

    it 'should manage isNotNullString comparison', ()->
      sql.isNotNullString("c7","k27").should.eql "c7 is not null"


  describe '#string comparison', ()->

    it 'should manage greaterOrEqualString comparison', ()->
      sql.greaterOrEqualString("c7","k27").should.eql "c7>='k27'"

    it 'should manage greaterString comparison', ()->
      sql.greaterString("c7","k27").should.eql "c7>'k27'"

    it 'should manage lessOrEqualString comparison', ()->
      sql.lessOrEqualString("c7","k27").should.eql "c7<='k27'"

    it 'should manage lessString comparison', ()->
      sql.lessString("c7","k27").should.eql "c7<'k27'"

    it 'should manage betweenString comparison', ()->
      sql.betweenString("c7","k27").should.eql
      "c7 between '${a_c7}' and '${b.c7}'"

  describe '#int comparison', ()->

    it 'should manage greaterOrEqualInt comparison', ()->
      expected= "idx.int.c7>='001000000000010'"
      sql.greaterOrEqualInt("c7",10).should.eql expected

    it 'should manage greaterInt comparison', ()->
      sql.greaterInt("c7",10).should.eql "idx.int.c7>'001000000000010'"

    it 'should manage lessOrEqualInt comparison', ()->
      sql.lessOrEqualInt("c7",10).should.eql "idx.int.c7<='001000000000010'"

    it 'should manage lessInt comparison', ()->
      sql.lessInt("c7",10).should.eql "idx.int.c7<'001000000000010'"

    it 'should manage betweenInt comparison', ()->
      expected= "idx.int.c7 between '001000000000010' and '001000000000012'"
      sql.betweenInt("c7",[10,12]).should.eql expected

  describe '#float comparison', ()->

    it 'should manage greaterOrEqualFloat comparison', ()->
      expected= "idx.float.c7>='001000000000010.4'"
      sql.greaterOrEqualFloat("c7",10.4).should.eql expected

    it 'should manage greaterFloat comparison', ()->
      sql.greaterFloat("c7",10.4).should.eql "idx.float.c7>'001000000000010.4'"

    it 'should manage lessOrEqualFloat comparison', ()->
      expected= "idx.float.c7<='001000000000010.4'"
      sql.lessOrEqualFloat("c7",10.4).should.eql expected

    it 'should manage lessFloat comparison', ()->
      sql.lessFloat("c7",10.4).should.eql "idx.float.c7<'001000000000010.4'"

    it 'should manage betweenFloat comparison', ()->
      expected= "idx.float.c7 between '001000000000010.4'"+
      " and '001000000000010.8'"
      sql.betweenFloat("c7",[10.4,10.8]).should.eql expected

  describe '#date comparison', ()->
    tim = CT.EX_ISO_DATETIME
    it 'should manage greaterOrEqualDate comparison', ()->
      expected= "idx.date.c7>='2013-06-13'"
      sql.greaterOrEqualDate("c7",tim).should.eql expected

    it 'should manage greaterDate comparison', ()->
      sql.greaterDate("c7",tim).should.eql "idx.date.c7>'2013-06-13'"

    it 'should manage lessOrEqualDate comparison', ()->
      expected= "idx.date.c7<='2013-06-13'"
      sql.lessOrEqualDate("c7",tim).should.eql expected

    it 'should manage lessDate comparison', ()->
      sql.lessDate("c7",tim).should.eql "idx.date.c7<'2013-06-13'"

    it 'should manage betweenDate comparison', ()->
      sql.betweenDate("c7",[tim,tim]).should.eql
      "idx.date.c7 between '2013-06-13' and '2013-06-13'"

  describe '#time comparison', ()->
    tim = CT.EX_ISO_DATETIME
    it 'should manage greaterOrEqualTime comparison', ()->
      expected= "idx.time.c7>='01:32:45'"
      sql.greaterOrEqualTime("c7",tim).should.eql expected

    it 'should manage greaterTime comparison', ()->
      sql.greaterTime("c7",tim).should.eql "idx.time.c7>'01:32:45'"

    it 'should manage lessOrEqualTime comparison', ()->
      expected= "idx.time.c7<='01:32:45'"
      sql.lessOrEqualTime("c7",tim).should.eql expected

    it 'should manage lessTime comparison', ()->
      sql.lessTime("c7",tim).should.eql "idx.time.c7<'01:32:45'"

    it 'should manage betweenTime comparison', ()->
      expected= "idx.time.c7 between '01:32:45' and '01:32:45'"
      sql.betweenTime("c7",[tim,tim]).should.eql expected

  describe '#year-month comparison', ()->
    tim = CT.EX_ISO_DATETIME
    it 'should manage greaterOrEqualYearMonth comparison', ()->
      expected= "idx.yearmonth.c7>='2013-06'"
      sql.greaterOrEqualYearMonth("c7",tim).should.eql expected

    it 'should manage greaterYearMonth comparison', ()->
      sql.greaterYearMonth("c7",tim).should.eql "idx.yearmonth.c7>'2013-06'"

    it 'should manage lessOrEqualYearMonth comparison', ()->
      expected= "idx.yearmonth.c7<='2013-06'"
      sql.lessOrEqualYearMonth("c7",tim).should.eql expected

    it 'should manage lessYearMonth comparison', ()->
      sql.lessYearMonth("c7",tim).should.eql "idx.yearmonth.c7<'2013-06'"

    it 'should manage betweenYearMonth comparison', ()->
      expected= "idx.yearmonth.c7 between '2013-06' and '2013-06'"
      sql.betweenYearMonth("c7",[tim,tim]).should.eql expected

  describe '#hour comparison', ()->
    tim = CT.EX_ISO_DATETIME
    it 'should manage greaterOrEqualHour comparison', ()->
      expected= "idx.hour.c7>='01'"
      sql.greaterOrEqualHour("c7",tim).should.eql expected

    it 'should manage greaterHour comparison', ()->
      sql.greaterHour("c7",tim).should.eql "idx.hour.c7>'01'"

    it 'should manage lessOrEqualHour comparison', ()->
      expected= "idx.hour.c7<='01'"
      sql.lessOrEqualHour("c7",tim).should.eql expected

    it 'should manage lessHour comparison', ()->
      sql.lessHour("c7",tim).should.eql "idx.hour.c7<'01'"

    it 'should manage betweenHour comparison', ()->
      expected= "idx.hour.c7 between '01' and '01'"
      sql.betweenHour("c7",[tim,tim]).should.eql expected

  describe '#in comparison', ()->
    it 'should manage isInString comparison', ()->
      expected= "c7 in ('aa','bb','cc')"
      sql.isInString("c7",["aa","bb","cc"]).should.eql expected

    it 'should manage isInInt comparison', ()->
      expected= "idx.int.c7 in ('001000000000012','001000000000003',"+
        "'001000000000014')"
      sql.isInInt("c7",["12",3,"14"]).should.eql expected

    it 'should manage isInFloat comparison', ()->
      expected= "idx.float.c7 in ('001000000000012.3','001000000000003.5',"+
        "'001000000000014.6')"
      sql.isInFloat("c7",["12.3",3.5,"14.6"]).should.eql expected

    it 'should manage isInSound comparison', ()->
      expected= "idx.metaphone.c7 in ('ALF','BT','SHRL')"
      sql.isInSound("c7",["alpha","beta","charlie"]).should.eql expected

    it 'should manage isInStem comparison', ()->
      expected= "idx.stem.c7 in ('alpha','beta','charli')"
      sql.isInStem("c7",["alpha","beta","charlie"]).should.eql expected

  describe '#List scripting', ()->

    abc= sql.where_('a','b','c')
    cde= sql.where_('c','d','e')

    it 'shoud create where clause', ()->
      sql.where_('a','b','c').should.eql ['b','a', 'c' ]

    it 'shoud support not operator', ()->
      sql.not_(abc).should.eql [ 'not', [ 'b', 'a', 'c' ] ]

    it 'shoud support and operator', ()->
      sql.and_('aa','bb').should.eql [ 'and', 'aa', 'bb' ]
      sql.and_('zz','bb','cc').should.eql [ 'and', 'zz', 'bb', 'cc' ]

    it 'shoud support or operator', ()->
      sql.or_('aa','bb').should.eql [ 'or', 'aa', 'bb' ]
      sql.or_('zz','bb','cc').should.eql [ 'or', 'zz', 'bb', 'cc' ]
    it 'shoud support complex query', ()->
      sql.or_(abc,sql.not_(cde)).should.eql
      [ 'or', [ 'b', 'a', 'c' ], [ 'not', [ 'd', 'c', 'e' ] ] ]

    it 'shoud swap characters', ()->
      sql.swapChar('a,b,c;e',';',',').should.eql 'a;b;c,e'

    it 'converts object to string for query', ()->
      sql.toScript(sql.or_(sql.abc,sql.not_(cde))).should.eql
      "('or',('a','b','c'),('not',('c','d','e')))"

    it 'converts string for query to object', ()->
      sql.fromScript("('or',('a','b','c'),('not',('c','d','e')))").should.eql
      sql.or_(abc,sql.not_(cde))

  describe '#normBool()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normBool undefined
      should.strictEqual null,sql.normBool ""
    it 'converts boolean values', ()->
      sql.normBool("True").should.eql "T"
      sql.normBool("False").should.eql "F"
      sql.normBool("OFF").should.eql "F"


  describe '#normInt()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normInt null
      should.strictEqual null,sql.normInt undefined
      should.strictEqual null,sql.normInt ""
    it 'converts integer values', ()->
      sql.normInt(123.4).should.eql "123"
      sql.normInt("127").should.eql "127"
      sql.normInt("127.2").should.eql "127"
      sql.normInt(-125.4).should.eql '-125'
      sql.normInt(0).should.eql '0'
      sql.normInt("-0").should.eql '0'

  describe '#normAddInt()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normAddInt "", undefined
    it 'adds integer values', ()->
      sql.normAddInt(2.3,"10").should.eql "12"
      sql.normAddInt(null,"10").should.eql "10"
      sql.normAddInt(-15,10).should.eql '-5'

  describe '#normAwsInt()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normAwsInt null
    it 'converts int to Aws value', ()->
      sql.normAwsInt(10).should.eql '001000000000010'
      sql.normAwsInt(-10).should.eql '000999999999990'
      sql.normAwsInt(PIVOT).should.eql '002000000000000'
      sql.normAwsInt(-1*PIVOT).should.eql '000000000000000'
      sql.normAwsInt(-1*PIVOT-1).should.be.an.instanceof Error
      sql.normAwsInt(PIVOT+1).should.be.an.instanceof Error

  describe '#normFloat()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normFloat null
      should.strictEqual null,sql.normFloat undefined
      should.strictEqual null,sql.normFloat ""
    it 'converts float values', ()->
      sql.normFloat(123.4).should.eql "123.4"
      sql.normFloat("127").should.eql "127"
      sql.normFloat("127.2").should.eql "127.2"
      sql.normFloat(-125.4).should.eql '-125.4'
      sql.normFloat(0).should.eql '0'
      sql.normFloat("-0").should.eql '0'

  describe '#normAddFloat()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normAddFloat "", undefined
    it 'adds float values', ()->
      sql.normAddFloat(2.3,"10").should.eql "12.3"
      sql.normAddFloat(null,"10.46").should.eql "10.46"
      sql.normAddFloat(-15.8,10.3).should.eql '-5.5'

  describe '#normAwsFloat()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normAwsFloat null
    it 'converts float to Aws value', ()->
      sql.normAwsFloat(10.4).should.eql '001000000000010.4'
      sql.normAwsFloat(-10.6).should.eql '000999999999989.4'
      sql.normAwsFloat(PIVOT).should.eql '002000000000000'
      sql.normAwsFloat(-1*PIVOT).should.eql '000000000000000'
      sql.normAwsFloat(-1*PIVOT-1).should.be.an.instanceof Error
      sql.normAwsFloat(PIVOT+1).should.be.an.instanceof Error

  describe '#normDateTime()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normDateTime null
      should.strictEqual null,sql.normDateTime undefined
      should.strictEqual null,sql.normDateTime ""
    it 'converts float to Aws value', ()->
      sql.normDateTime(new Date()).should.exist
      sql.normDateTime('2013-02-04T10:35:24-08:00').should.eql
      '2013-02-04T18:35:24.000Z'

  describe '#normTime()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normTime null
      should.strictEqual null,sql.normTime undefined
      should.strictEqual null,sql.normTime ""
    it 'converts date-time to time', ()->
      sql.normTime(new Date()).should.exist
      sql.normTime('2013-02-04T10:35:24-08:00').should.eql '18:35:24'

  describe '#normHour()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normHour null
      should.strictEqual null,sql.normHour undefined
      should.strictEqual null,sql.normHour ""
    it 'converts date-time to hour', ()->
      sql.normHour(new Date()).should.exist
      sql.normHour('2013-02-04T10:35:24-08:00').should.eql '18'

  describe '#normDayOfWeek()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normDayOfWeek null
      should.strictEqual null,sql.normDayOfWeek undefined
      should.strictEqual null,sql.normDayOfWeek ""
    it 'converts date-time to day of the week', ()->
      sql.normDayOfWeek(new Date()).should.exist
      sql.normDayOfWeek('2013-02-04T10:35:24-08:00').should.eql '1'

  describe '#normYearMonth()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.normYearMonth null
      should.strictEqual null,sql.normYearMonth undefined
      should.strictEqual null,sql.normYearMonth ""
    it 'converts date-time to year and month', ()->
      sql.normYearMonth(new Date()).should.exist
      sql.normYearMonth('2013-02-04T10:35:24-08:00').should.eql
      '2013-02'

  describe '#simplifyString()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.simplifyString null
      should.strictEqual null,sql.simplifyString undefined
      should.strictEqual null,sql.simplifyString ""
    it 'simplifies strings of punctuations', ()->
      sql.simplifyString("Silly o'Connor, -Sentence;").should.eql
      'silly o connor sentence'

  describe '#stemStringGB()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.stemStringGB null
      should.strictEqual null,sql.stemStringGB undefined
      should.strictEqual null,sql.stemStringGB ""
    it 'stems all the words', ()->
      sentence= "A wish If you're going through Hells,, keep going."
      sql.stemStringGB(sentence).
      should.eql [ 'hell', 'keep', 'through', 'wish', 'you' ]

  describe '#methaphoneString()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.methaphoneString null
      should.strictEqual null,sql.methaphoneString undefined
      should.strictEqual null,sql.methaphoneString ""
    it 'applies metaphone to all the words', ()->
      sentence= "A wish If you're going through Hells,, keep going."
      sql.methaphoneString(sentence).
      should.eql [ '0RKH', 'HLS', 'IF', 'KNK', 'KP', 'WKSH' ]

  describe '#domainOfProfileRef()', ()->
    it 'clears empty values', ()->
      should.strictEqual null,sql.domainOfProfileRef null
      should.strictEqual null,sql.domainOfProfileRef undefined
      should.strictEqual null,sql.domainOfProfileRef ""
    it 'extracts the domain informations', ()->
      sql.domainOfProfileRef('email:z@c.b.com').
      should.eql [ 'com', 'b', 'c' ]


  describe 'statementToSQL', ()->
    aa= sql.where_ "AA","equalString","AAA"
    bb= sql.where_ "BB","equalStem","BBB"
    cc= sql.where_ "CC","equalString","CCC"
    dd= sql.where_ "DD","equalString","DDD"
    ee= sql.where_ "EE","equalSound","EEE"
    ff= sql.where_ "FF","equalString","FFF"
    it 'should support where predicate', ()->
      tim = CT.EX_ISO_DATETIME
      expected= "idx.date.col123='2013-06-13'"
      sql.predicateToSQL(["equalDate","col123",tim]).should.eql expected

    it 'shoud generate SQL from array script', ()->
      clause= sql.or_ aa,sql.not_(bb),sql.and_(cc,dd)
      expected= "(AA='AAA' OR  NOT ((idx.stem.BB='bbb'))"
      expected=expected+" OR (CC='CCC' AND DD='DDD'))"
      sql.statementToSQL(clause).should.eql expected

  describe 'selectForUser', ()->
    aa= sql.where_ "AA","equalString","AAA"
    bb= sql.where_ "BB","equalStem","BBB"
    cc= sql.where_ "CC","equalString","CCC"
    dd= sql.where_ "DD","equalString","DDD"
    ee= sql.where_ "EE","equalSound","EEE"
    ff= sql.where_ "FF","equalString","FFF"
    it 'shoud generate SQL from array script', ()->
      clause= sql.or_ aa,sql.not_(bb),sql.and_(cc,dd)
      expected= "select * from user where "+
      "ownerRef='email:magma.test.u1.77225432@flarebyte.com' "+
      "AND gateId='magma:f/gate/123456789' AND "+
        "(AA='AAA' OR  NOT ((idx.stem.BB='bbb'))"
      expected=expected+" OR (CC='CCC' AND DD='DDD')) limit 20"
      sql.selectForUser(userCtx, clause).should.eql expected
    it 'shoud generate SQL from array script with sort and limit', ()->
      clause= sql.or_ aa,sql.not_(bb),sql.and_(cc,dd)
      expected= "select * from user where "+
      "ownerRef='email:magma.test.u1.77225432@flarebyte.com' "+
      "AND gateId='magma:f/gate/123456789' AND "+
        "(AA='AAA' OR  NOT ((idx.stem.BB='bbb'))"
      expected=expected+" OR (CC='CCC' AND DD='DDD'))"+
      " order by AA DESC limit 35"
      sql.selectForUser(userCtx, clause,"AA DESC",35).should.eql expected
    it 'shoud generate SQL from array script with universe', ()->
      clause= sql.or_ aa,sql.not_(bb),sql.and_(cc,dd)
      expected= "select * from user where "+
      "ownerRef='email:magma.test.u1.77225432@flarebyte.com' "+
      "AND gateId='magma:f/gate/123456789'"+
      " AND universeId='magma:f/universe/testing_olivier_27' AND "+
      "(AA='AAA' OR  NOT ((idx.stem.BB='bbb'))"
      expected=expected+" OR (CC='CCC' AND DD='DDD'))"+
      " order by AA limit 35"
      uCtx=_.cloneDeep(userCtx)
      uCtx.my.universeId= CT.EX_UNIVERSE_ID
      sql.selectForUser(uCtx, clause,"AA",35).should.eql expected
