// Generated by CoffeeScript 1.7.1

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
CoffeeLint is freely distributable under the MIT license.
 */

(function() {
  var ASTLinter, CoffeeScript, ERROR, IGNORE, LexicalLinter, LineLinter, RULES, WARN, coffeelint, cs, defaults, difference, extend, hasSyntaxError, mergeDefaultConfig, packageJSON, _rules,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  coffeelint = exports;

  if (typeof window !== "undefined" && window !== null) {
    CoffeeScript = window.CoffeeScript;
  } else {
    cs = 'coffee-script';
    CoffeeScript = require(cs);
  }

  packageJSON = require('./../package.json');

  coffeelint.VERSION = packageJSON.version;

  ERROR = 'error';

  WARN = 'warn';

  IGNORE = 'ignore';

  coffeelint.RULES = RULES = require('./rules.coffee');

  extend = function() {
    var destination, k, source, sources, v, _i, _len;
    destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        destination[k] = v;
      }
    }
    return destination;
  };

  defaults = function(source, defaults) {
    return extend({}, defaults, source);
  };

  difference = function(a, b) {
    var j, _ref, _results;
    j = 0;
    _results = [];
    while (j < a.length) {
      if (_ref = a[j], __indexOf.call(b, _ref) >= 0) {
        _results.push(a.splice(j, 1));
      } else {
        _results.push(j++);
      }
    }
    return _results;
  };

  LineLinter = require('./line_linter.coffee');

  LexicalLinter = require('./lexical_linter.coffee');

  ASTLinter = require('./ast_linter.coffee');

  mergeDefaultConfig = function(userConfig) {
    var config, rule, ruleConfig;
    config = {};
    for (rule in RULES) {
      ruleConfig = RULES[rule];
      config[rule] = defaults(userConfig[rule], ruleConfig);
    }
    return config;
  };

  coffeelint.invertLiterate = function(source) {
    var line, newSource, _i, _len, _ref;
    source = CoffeeScript.helpers.invertLiterate(source);
    newSource = "";
    _ref = source.split("\n");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (line.match(/^#/)) {
        line = line.replace(/\s*$/, '');
      }
      line = line.replace(/^\s{4}/g, '');
      newSource += "" + line + "\n";
    }
    return newSource;
  };

  _rules = {};

  coffeelint.registerRule = function(RuleConstructor, ruleName) {
    var e, name, p, _ref, _ref1;
    if (ruleName == null) {
      ruleName = void 0;
    }
    p = new RuleConstructor;
    name = (p != null ? (_ref = p.rule) != null ? _ref.name : void 0 : void 0) || "(unknown)";
    e = function(msg) {
      throw new Error("Invalid rule: " + name + " " + msg);
    };
    if (p.rule == null) {
      e("Rules must provide rule attribute with a default configuration.");
    }
    if (p.rule.name == null) {
      e("Rule defaults require a name");
    }
    if ((ruleName != null) && ruleName !== p.rule.name) {
      e("Mismatched rule name: " + ruleName);
    }
    if (p.rule.message == null) {
      e("Rule defaults require a message");
    }
    if (p.rule.description == null) {
      e("Rule defaults require a description");
    }
    if ((_ref1 = p.rule.level) !== 'ignore' && _ref1 !== 'warn' && _ref1 !== 'error') {
      e("Default level must be 'ignore', 'warn', or 'error'");
    }
    if (typeof p.lintToken === 'function') {
      if (!p.tokens) {
        e("'tokens' is required for 'lintToken'");
      }
    } else if (typeof p.lintLine !== 'function' && typeof p.lintAST !== 'function') {
      e("Rules must implement lintToken, lintLine, or lintAST");
    }
    RULES[p.rule.name] = p.rule;
    return _rules[p.rule.name] = RuleConstructor;
  };

  coffeelint.registerRule(require('./rules/arrow_spacing.coffee'));

  coffeelint.registerRule(require('./rules/no_tabs.coffee'));

  coffeelint.registerRule(require('./rules/no_trailing_whitespace.coffee'));

  coffeelint.registerRule(require('./rules/max_line_length.coffee'));

  coffeelint.registerRule(require('./rules/line_endings.coffee'));

  coffeelint.registerRule(require('./rules/no_trailing_semicolons.coffee'));

  coffeelint.registerRule(require('./rules/indentation.coffee'));

  coffeelint.registerRule(require('./rules/camel_case_classes.coffee'));

  coffeelint.registerRule(require('./rules/colon_assignment_spacing.coffee'));

  coffeelint.registerRule(require('./rules/no_implicit_braces.coffee'));

  coffeelint.registerRule(require('./rules/no_plusplus.coffee'));

  coffeelint.registerRule(require('./rules/no_throwing_strings.coffee'));

  coffeelint.registerRule(require('./rules/no_backticks.coffee'));

  coffeelint.registerRule(require('./rules/no_implicit_parens.coffee'));

  coffeelint.registerRule(require('./rules/no_empty_param_list.coffee'));

  coffeelint.registerRule(require('./rules/no_stand_alone_at.coffee'));

  coffeelint.registerRule(require('./rules/space_operators.coffee'));

  coffeelint.registerRule(require('./rules/duplicate_key.coffee'));

  coffeelint.registerRule(require('./rules/empty_constructor_needs_parens.coffee'));

  coffeelint.registerRule(require('./rules/cyclomatic_complexity.coffee'));

  coffeelint.registerRule(require('./rules/newlines_after_classes.coffee'));

  coffeelint.registerRule(require('./rules/no_unnecessary_fat_arrows.coffee'));

  coffeelint.registerRule(require('./rules/missing_fat_arrows.coffee'));

  coffeelint.registerRule(require('./rules/non_empty_constructor_needs_parens.coffee'));

  hasSyntaxError = function(source) {
    try {
      CoffeeScript.tokens(source);
      return false;
    } catch (_error) {}
    return true;
  };

  coffeelint.lint = function(source, userConfig, literate) {
    var all_errors, astErrors, block_config, cmd, config, disabled, disabled_initially, e, errors, i, l, lexErrors, lexicalLinter, lineErrors, lineLinter, next_line, r, rules, s, tokensByLine, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
    if (userConfig == null) {
      userConfig = {};
    }
    if (literate == null) {
      literate = false;
    }
    if (literate) {
      source = this.invertLiterate(source);
    }
    config = mergeDefaultConfig(userConfig);
    disabled_initially = [];
    _ref = source.split('\n');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      l = _ref[_i];
      s = LineLinter.configStatement.exec(l);
      if ((s != null ? s.length : void 0) > 2 && __indexOf.call(s, 'enable') >= 0) {
        _ref1 = s.slice(1);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          r = _ref1[_j];
          if (r !== 'enable' && r !== 'disable') {
            if (!(r in config && ((_ref2 = config[r].level) === 'warn' || _ref2 === 'error'))) {
              disabled_initially.push(r);
              config[r] = {
                level: 'error'
              };
            }
          }
        }
      }
    }
    astErrors = new ASTLinter(source, config, _rules, CoffeeScript).lint();
    errors = [].concat(astErrors);
    if (!hasSyntaxError(source)) {
      lexicalLinter = new LexicalLinter(source, config, _rules, CoffeeScript);
      lexErrors = lexicalLinter.lint();
      errors = errors.concat(lexErrors);
      tokensByLine = lexicalLinter.tokensByLine;
      lineLinter = new LineLinter(source, config, _rules, tokensByLine, literate);
      lineErrors = lineLinter.lint();
      errors = errors.concat(lineErrors);
      block_config = lineLinter.block_config;
    } else {
      block_config = {
        enable: {},
        disable: {}
      };
    }
    errors.sort(function(a, b) {
      return a.lineNumber - b.lineNumber;
    });
    all_errors = errors;
    errors = [];
    disabled = disabled_initially;
    next_line = 0;
    for (i = _k = 0, _ref3 = source.split('\n').length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
      for (cmd in block_config) {
        rules = block_config[cmd][i];
        if (rules != null) {
          ({
            'disable': function() {
              return disabled = disabled.concat(rules);
            },
            'enable': function() {
              difference(disabled, rules);
              if (rules.length === 0) {
                return disabled = disabled_initially;
              }
            }
          })[cmd]();
        }
      }
      while (next_line === i && all_errors.length > 0) {
        next_line = all_errors[0].lineNumber - 1;
        e = all_errors[0];
        if (e.lineNumber === i + 1 || (e.lineNumber == null)) {
          e = all_errors.shift();
          if (_ref4 = e.rule, __indexOf.call(disabled, _ref4) < 0) {
            errors.push(e);
          }
        }
      }
    }
    return errors;
  };

}).call(this);

//# sourceMappingURL=coffeelint.map
