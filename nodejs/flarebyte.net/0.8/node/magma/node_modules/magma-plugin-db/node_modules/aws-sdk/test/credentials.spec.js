// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, validateCredentials;

  AWS = require('../lib/core');

  validateCredentials = function(creds, key, secret, session) {
    expect(creds.accessKeyId).toEqual(key || 'akid');
    expect(creds.secretAccessKey).toEqual(secret || 'secret');
    return expect(creds.sessionToken).toEqual(session || 'session');
  };

  describe('AWS.Credentials', function() {
    describe('constructor', function() {
      it('should allow setting of credentials with keys', function() {
        var config;
        config = new AWS.Config({
          accessKeyId: 'akid',
          secretAccessKey: 'secret',
          sessionToken: 'session'
        });
        return validateCredentials(config.credentials);
      });
      it('should allow setting of credentials as object', function() {
        var creds;
        creds = {
          accessKeyId: 'akid',
          secretAccessKey: 'secret',
          sessionToken: 'session'
        };
        return validateCredentials(new AWS.Credentials(creds));
      });
      return it('defaults credentials to undefined when not passed', function() {
        var creds;
        creds = new AWS.Credentials();
        expect(creds.accessKeyId).toBe(void 0);
        expect(creds.secretAccessKey).toBe(void 0);
        return expect(creds.sessionToken).toBe(void 0);
      });
    });
    describe('needsRefresh', function() {
      it('needs refresh if credentials are not set', function() {
        var creds;
        creds = new AWS.Credentials();
        expect(creds.needsRefresh()).toEqual(true);
        creds = new AWS.Credentials('akid');
        return expect(creds.needsRefresh()).toEqual(true);
      });
      it('does not need refresh if credentials are set', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        return expect(creds.needsRefresh()).toEqual(false);
      });
      return it('needs refresh if creds are expired', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = true;
        return expect(creds.needsRefresh()).toEqual(true);
      });
    });
    return describe('get', function() {
      it('does not call refresh if not needsRefresh', function() {
        var creds, refresh, spy;
        spy = jasmine.createSpy('done callback');
        creds = new AWS.Credentials('akid', 'secret');
        refresh = spyOn(creds, 'refresh');
        creds.get(spy);
        expect(refresh).not.toHaveBeenCalled();
        expect(spy).toHaveBeenCalled();
        expect(spy.argsForCall[0][0]).toEqual(null);
        return expect(creds.expired).toEqual(false);
      });
      return it('calls refresh only if needsRefresh', function() {
        var creds, refresh, spy;
        spy = jasmine.createSpy('done callback');
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = true;
        refresh = spyOn(creds, 'refresh').andCallThrough();
        creds.get(spy);
        expect(refresh).toHaveBeenCalled();
        expect(spy).toHaveBeenCalled();
        expect(spy.argsForCall[0][0]).toEqual(null);
        return expect(creds.expired).toEqual(false);
      });
    });
  });

  describe('AWS.EnvironmentCredentials', function() {
    beforeEach(function() {
      return process.env = {};
    });
    describe('constructor', function() {
      it('should be able to read credentials from env with a prefix', function() {
        var creds;
        process.env.AWS_ACCESS_KEY_ID = 'akid';
        process.env.AWS_SECRET_ACCESS_KEY = 'secret';
        process.env.AWS_SESSION_TOKEN = 'session';
        creds = new AWS.EnvironmentCredentials('AWS');
        return validateCredentials(creds);
      });
      return it('should be able to read credentials from env without a prefix', function() {
        var creds;
        process.env.ACCESS_KEY_ID = 'akid';
        process.env.SECRET_ACCESS_KEY = 'secret';
        process.env.SESSION_TOKEN = 'session';
        creds = new AWS.EnvironmentCredentials();
        return validateCredentials(creds);
      });
    });
    return describe('refresh', function() {
      return it('can refresh credentials', function() {
        var creds;
        process.env.AWS_ACCESS_KEY_ID = 'akid';
        process.env.AWS_SECRET_ACCESS_KEY = 'secret';
        creds = new AWS.EnvironmentCredentials('AWS');
        expect(creds.accessKeyId).toEqual('akid');
        creds.accessKeyId = 'not_akid';
        expect(creds.accessKeyId).not.toEqual('akid');
        creds.refresh();
        return expect(creds.accessKeyId).toEqual('akid');
      });
    });
  });

  describe('AWS.FileSystemCredentials', function() {
    describe('constructor', function() {
      it('should accept filename and load credentials from root doc', function() {
        var creds, mock;
        mock = '{"accessKeyId":"akid", "secretAccessKey":"secret","sessionToken":"session"}';
        spyOn(AWS.util, 'readFileSync').andReturn(mock);
        creds = new AWS.FileSystemCredentials('foo');
        return validateCredentials(creds);
      });
      return it('should accept filename and load credentials from credentials block', function() {
        var creds, mock, spy;
        mock = '{"credentials":{"accessKeyId":"akid", "secretAccessKey":"secret","sessionToken":"session"}}';
        spy = spyOn(AWS.util, 'readFileSync').andReturn(mock);
        creds = new AWS.FileSystemCredentials('foo');
        return validateCredentials(creds);
      });
    });
    return describe('refresh', function() {
      it('should refresh from given filename', function() {
        var creds, mock;
        mock = '{"credentials":{"accessKeyId":"RELOADED", "secretAccessKey":"RELOADED","sessionToken":"RELOADED"}}';
        spyOn(AWS.util, 'readFileSync').andReturn(mock);
        creds = new AWS.FileSystemCredentials('foo');
        return validateCredentials(creds, 'RELOADED', 'RELOADED', 'RELOADED');
      });
      return it('fails if credentials are not in the file', function() {
        var mock;
        mock = '{"credentials":{}}';
        spyOn(AWS.util, 'readFileSync').andReturn(mock);
        new AWS.FileSystemCredentials('foo').refresh(function(err) {
          return expect(err.message).toEqual('Credentials not set in foo');
        });
        return expect(function() {
          return new AWS.FileSystemCredentials('foo').refresh();
        }).toThrow('Credentials not set in foo');
      });
    });
  });

  describe('AWS.EC2MetadataCredentials', function() {
    describe('constructor', function() {
      return it('allows passing of AWS.MetadataService options', function() {
        var creds;
        creds = new AWS.EC2MetadataCredentials({
          host: 'host'
        });
        return expect(creds.metadataService.host).toEqual('host');
      });
    });
    return describe('refresh', function() {
      it('loads credentials from EC2 Metadata service', function() {
        var creds, spy;
        creds = new AWS.EC2MetadataCredentials({
          host: 'host'
        });
        spy = spyOn(creds.metadataService, 'loadCredentials').andCallFake(function(cb) {
          return cb(null, {
            Code: "Success",
            AccessKeyId: "KEY",
            SecretAccessKey: "SECRET",
            Token: "TOKEN"
          });
        });
        creds.refresh(function() {});
        expect(creds.metadata.Code).toEqual('Success');
        expect(creds.accessKeyId).toEqual('KEY');
        expect(creds.secretAccessKey).toEqual('SECRET');
        return expect(creds.sessionToken).toEqual('TOKEN');
      });
      return it('does not try to load creds second time if Metadata service failed', function() {
        var creds, spy;
        creds = new AWS.EC2MetadataCredentials({
          host: 'host'
        });
        spy = spyOn(creds.metadataService, 'loadCredentials').andCallFake(function(cb) {
          return cb(new Error('INVALID SERVICE'));
        });
        creds.refresh(function(err) {
          return expect(err.message).toEqual('INVALID SERVICE');
        });
        return creds.refresh(function() {
          return creds.refresh(function() {
            return creds.refresh(function() {
              return expect(spy.calls.length).toEqual(1);
            });
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=credentials.spec.map
