// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, MockService, helpers;

  helpers = require('./helpers');

  AWS = helpers.AWS;

  MockService = helpers.MockService;

  describe('AWS.EventListeners', function() {
    var completeHandler, config, delays, errorHandler, makeRequest, oldSetTimeout, retryHandler, service, successHandler, totalWaited;
    oldSetTimeout = setTimeout;
    config = null;
    service = null;
    totalWaited = null;
    delays = [];
    successHandler = null;
    errorHandler = null;
    completeHandler = null;
    retryHandler = null;
    beforeEach(function() {
      setTimeout = jasmine.createSpy('setTimeout');;
      setTimeout.andCallFake(function(callback, delay) {
        totalWaited += delay;
        delays.push(delay);
        return callback();
      });
      totalWaited = 0;
      delays = [];
      service = new MockService({
        maxRetries: 3
      });
      service.config.credentials = AWS.util.copy(service.config.credentials);
      successHandler = createSpy('success');
      errorHandler = createSpy('error');
      completeHandler = createSpy('complete');
      return retryHandler = createSpy('retry');
    });
    afterEach(function() {
      return setTimeout = oldSetTimeout;
    });
    makeRequest = function(callback) {
      var request;
      request = service.makeRequest('mockMethod', {
        foo: 'bar'
      });
      request.on('retry', retryHandler);
      request.on('error', errorHandler);
      request.on('success', successHandler);
      request.on('complete', completeHandler);
      if (callback) {
        request.on('complete', function(resp) {
          return callback.call(resp, resp.error, resp.data);
        });
        return request.send();
      } else {
        return request;
      }
    };
    describe('validate', function() {
      it('takes the request object as a parameter', function() {
        var request, response;
        request = makeRequest();
        request.on('validate', function(req) {
          expect(req).toBe(request);
          throw "ERROR";
        });
        response = request.send();
        return expect(response.error).toEqual("ERROR");
      });
      it('sends error event if credentials are not set', function() {
        var request;
        errorHandler = createSpy('errorHandler');
        request = makeRequest();
        request.on('error', errorHandler);
        service.config.credentialProvider = null;
        service.config.credentials.accessKeyId = null;
        request.send();
        service.config.credentials.accessKeyId = 'akid';
        service.config.credentials.secretAccessKey = null;
        request.send();
        expect(errorHandler).toHaveBeenCalled();
        return AWS.util.arrayEach(errorHandler.calls, function(call) {
          expect(call.args[0] instanceof Error).toBeTruthy();
          expect(call.args[0].code).toEqual('SigningError');
          return expect(call.args[0].message).toMatch(/Missing credentials in config/);
        });
      });
      return it('sends error event if region is not set', function() {
        var call, request;
        service.config.region = null;
        request = makeRequest(function() {});
        call = errorHandler.calls[0];
        expect(errorHandler).toHaveBeenCalled();
        expect(call.args[0] instanceof Error).toBeTruthy();
        expect(call.args[0].code).toEqual('SigningError');
        return expect(call.args[0].message).toMatch(/Missing region in config/);
      });
    });
    describe('build', function() {
      return it('takes the request object as a parameter', function() {
        var request, response;
        request = makeRequest();
        request.on('build', function(req) {
          expect(req).toBe(request);
          throw "ERROR";
        });
        response = request.send();
        return expect(response.error).toEqual("ERROR");
      });
    });
    describe('afterBuild', function() {
      var contentLength, sendRequest;
      beforeEach(function() {
        return helpers.mockHttpResponse(200, {}, ['DATA']);
      });
      sendRequest = function(body) {
        var request;
        request = makeRequest();
        request.on('build', function(req) {
          return req.httpRequest.body = body;
        });
        request.send();
        return request;
      };
      contentLength = function(body) {
        return sendRequest(body).httpRequest.headers['Content-Length'];
      };
      it('builds Content-Length in the request headers for string content', function() {
        return expect(contentLength('FOOBAR')).toEqual(6);
      });
      it('builds Content-Length for string "0"', function() {
        return expect(contentLength('0')).toEqual(1);
      });
      it('builds Content-Length for utf-8 string body', function() {
        return expect(contentLength('tï№')).toEqual(6);
      });
      it('builds Content-Length for buffer body', function() {
        return expect(contentLength(new Buffer('tï№'))).toEqual(6);
      });
      return it('builds Content-Length for file body', function() {
        var file, fileLen, fs;
        fs = require('fs');
        file = fs.createReadStream(__filename);
        fileLen = fs.lstatSync(file.path).size;
        return expect(contentLength(file)).toEqual(fileLen);
      });
    });
    describe('sign', function() {
      it('takes the request object as a parameter', function() {
        var request, response;
        request = makeRequest();
        request.on('sign', function(req) {
          expect(req).toBe(request);
          throw "ERROR";
        });
        response = request.send();
        return expect(response.error).toEqual("ERROR");
      });
      it('uses the api.signingName if provided', function() {
        var request, response;
        service.api.signingName = 'SIGNING_NAME';
        spyOn(AWS.Signers.RequestSigner, 'getVersion').andCallFake(function() {
          return function(req, signingName) {
            throw signingName;
          };
        });
        request = makeRequest();
        response = request.send();
        expect(response.error).toEqual('SIGNING_NAME');
        return delete service.api.signingName;
      });
      return it('uses the api.endpointPrefix if signingName not provided', function() {
        var request, response;
        spyOn(AWS.Signers.RequestSigner, 'getVersion').andCallFake(function() {
          return function(req, signingName) {
            throw signingName;
          };
        });
        request = makeRequest();
        response = request.send();
        return expect(response.error).toEqual('mockservice');
      });
    });
    describe('send', function() {
      return it('passes httpOptions from config', function() {
        var options;
        options = {};
        spyOn(AWS.HttpClient, 'getInstance').andReturn({
          handleRequest: function(req, opts) {
            return options = opts;
          }
        });
        service.config.httpOptions = {
          timeout: 15
        };
        service.config.maxRetries = 0;
        makeRequest(function() {});
        return expect(options.timeout).toEqual(15);
      });
    });
    describe('httpData', function() {
      beforeEach(function() {
        return helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
      });
      it('emits httpData event on each chunk', function() {
        var calls, request;
        calls = [];
        request = makeRequest();
        request.on('httpData', function(chunk) {
          return calls.push(chunk.toString());
        });
        request.send();
        return expect(calls).toEqual(['FOO', 'BAR', 'BAZ', 'QUX']);
      });
      return it('does not clear default httpData event if another is added', function() {
        var request, response;
        request = makeRequest();
        request.on('httpData', function() {});
        response = request.send();
        return expect(response.httpResponse.body.toString()).toEqual('FOOBARBAZQUX');
      });
    });
    describe('retry', function() {
      it('retries a request with a set maximum retries', function() {
        var request, response, sendHandler;
        sendHandler = createSpy('send');
        service.config.maxRetries = 10;
        helpers.mockHttpResponse({
          code: 'NetworkingError',
          message: 'Cannot connect'
        });
        request = makeRequest();
        request.on('send', sendHandler);
        response = request.send();
        expect(retryHandler).toHaveBeenCalled();
        expect(errorHandler).toHaveBeenCalled();
        expect(completeHandler).toHaveBeenCalled();
        expect(successHandler).not.toHaveBeenCalled();
        expect(response.retryCount).toEqual(service.config.maxRetries);
        return expect(sendHandler.calls.length).toEqual(service.config.maxRetries + 1);
      });
      it('retries with falloff', function() {
        helpers.mockHttpResponse({
          code: 'NetworkingError',
          message: 'Cannot connect'
        });
        makeRequest(function() {});
        return expect(delays).toEqual([30, 60, 120]);
      });
      it('retries if status code is >= 500', function() {
        helpers.mockHttpResponse(500, {}, '');
        return makeRequest(function(err) {
          expect(err).toEqual({
            code: 500,
            message: null,
            statusCode: 500,
            retryable: true
          });
          return expect(this.retryCount).toEqual(service.config.maxRetries);
        });
      });
      it('should not emit error if retried fewer than maxRetries', function() {
        var response;
        helpers.mockIntermittentFailureResponse(2, 200, {}, 'foo');
        response = makeRequest(function() {});
        expect(totalWaited).toEqual(90);
        expect(response.retryCount).toBeLessThan(service.config.maxRetries);
        expect(response.data).toEqual('foo');
        return expect(errorHandler).not.toHaveBeenCalled();
      });
      ['ExpiredToken', 'ExpiredTokenException', 'RequestExpired'].forEach(function(name) {
        return it('invalidates expired credentials and retries', function() {
          var creds, response;
          spyOn(AWS.HttpClient, 'getInstance');
          AWS.HttpClient.getInstance.andReturn({
            handleRequest: function(req, opts, cb, errCb) {
              if (req.headers.Authorization.match('Credential=INVALIDKEY')) {
                return helpers.mockHttpSuccessfulResponse(403, {}, name, cb);
              } else {
                return helpers.mockHttpSuccessfulResponse(200, {}, 'DATA', cb);
              }
            }
          });
          creds = {
            numCalls: 0,
            expired: false,
            accessKeyId: 'INVALIDKEY',
            secretAccessKey: 'INVALIDSECRET',
            get: function(cb) {
              if (this.expired) {
                this.numCalls += 1;
                this.expired = false;
                this.accessKeyId = 'VALIDKEY' + this.numCalls;
                this.secretAccessKey = 'VALIDSECRET' + this.numCalls;
              }
              return cb();
            }
          };
          service.config.credentials = creds;
          response = makeRequest(function() {});
          expect(response.retryCount).toEqual(1);
          expect(creds.accessKeyId).toEqual('VALIDKEY1');
          return expect(creds.secretAccessKey).toEqual('VALIDSECRET1');
        });
      });
      [301, 307].forEach(function(code) {
        return it('attempts to redirect on ' + code + ' responses', function() {
          var response;
          helpers.mockHttpResponse(code, {
            location: 'http://redirected'
          }, '');
          service.config.maxRetries = 0;
          service.config.maxRedirects = 5;
          response = makeRequest(function() {});
          expect(response.request.httpRequest.endpoint.host).toEqual('redirected');
          expect(response.error.retryable).toEqual(true);
          expect(response.redirectCount).toEqual(service.config.maxRedirects);
          return expect(delays).toEqual([0, 0, 0, 0, 0]);
        });
      });
      return it('does not redirect if 3xx is missing location header', function() {
        var response;
        helpers.mockHttpResponse(304, {}, '');
        service.config.maxRetries = 0;
        response = makeRequest(function() {});
        expect(response.request.httpRequest.endpoint.host).not.toEqual('redirected');
        return expect(response.error.retryable).toEqual(false);
      });
    });
    describe('success', function() {
      return it('emits success on a successful response', function() {
        var response;
        helpers.mockHttpResponse(200, {}, 'Success!');
        response = makeRequest(function() {});
        expect(retryHandler).not.toHaveBeenCalled();
        expect(errorHandler).not.toHaveBeenCalled();
        expect(completeHandler).toHaveBeenCalled();
        expect(successHandler).toHaveBeenCalled();
        return expect(response.retryCount).toEqual(0);
      });
    });
    return describe('error', function() {
      it('emits error if error found and should not be retrying', function() {
        var response;
        helpers.mockHttpResponse(400, {}, '');
        response = makeRequest(function() {});
        expect(retryHandler).not.toHaveBeenCalled();
        expect(errorHandler).toHaveBeenCalled();
        expect(completeHandler).toHaveBeenCalled();
        expect(successHandler).not.toHaveBeenCalled();
        return expect(response.retryCount).toEqual(0);
      });
      it('emits error if an error is set in extractError', function() {
        var error, extractDataHandler, request, response;
        error = {
          code: 'ParseError',
          message: 'error message'
        };
        extractDataHandler = createSpy('extractData');
        helpers.mockHttpResponse(400, {}, '');
        request = makeRequest();
        request.on('extractData', extractDataHandler);
        request.on('extractError', function(resp) {
          return resp.error = error;
        });
        response = request.send();
        expect(response.error).toBe(error);
        expect(extractDataHandler).not.toHaveBeenCalled();
        expect(retryHandler).not.toHaveBeenCalled();
        expect(errorHandler).toHaveBeenCalled();
        return expect(completeHandler).toHaveBeenCalled();
      });
      return it('catches exceptions raised from error event', function() {
        var request;
        helpers.mockHttpResponse(500, {}, []);
        request = makeRequest();
        request.on('error', function() {
          throw "ERROR";
        });
        expect(function() {
          return request.send();
        }).toThrow('ERROR');
        return expect(completeHandler).not.toHaveBeenCalled();
      });
    });
  });

}).call(this);

//# sourceMappingURL=event_listeners.spec.map
