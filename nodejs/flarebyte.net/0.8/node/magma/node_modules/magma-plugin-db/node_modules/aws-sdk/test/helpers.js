// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, EventEmitter, MockService, flattenXML, matchXML, mockHttpResponse, mockHttpSuccessfulResponse, mockIntermittentFailureResponse;

  AWS = require('../lib/aws');

  EventEmitter = require('events').EventEmitter;

  AWS.config.update({
    region: 'mock-region',
    credentials: {
      accessKeyId: 'akid',
      secretAccessKey: 'secret'
    }
  });

  AWS.EventListeners.Core.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);

  setTimeout = function(fn, delay) { fn(); };

  flattenXML = function(xml) {
    if (!xml) {
      return xml;
    }
    return xml.split("\n").join('').replace(/>\s+</g, '><').replace(/^\s+|\s+$/g, '');
  };

  matchXML = function(xml1, xml2) {
    return expect(flattenXML(xml1)).toEqual(flattenXML(xml2));
  };

  MockService = AWS.Service.defineService('mockService', {
    initialize: function(config) {
      AWS.Service.prototype.initialize.call(this, config);
      this.config.credentials = {
        accessKeyId: 'akid',
        secretAccessKey: 'secret'
      };
      return this.config.region = 'mock-region';
    },
    setupRequestListeners: function(request) {
      request.on('extractData', function(resp) {
        return resp.data = resp.httpResponse.body.toString();
      });
      return request.on('extractError', function(resp) {
        return resp.error = {
          code: resp.httpResponse.body.toString() || resp.httpResponse.statusCode,
          message: null
        };
      });
    },
    api: {
      endpointPrefix: 'mockservice',
      signatureVersion: 'v4'
    }
  });

  mockHttpSuccessfulResponse = function(status, headers, data, cb) {
    var httpResp;
    if (!Array.isArray(data)) {
      data = [data];
    }
    httpResp = new EventEmitter();
    httpResp.statusCode = status;
    httpResp.headers = headers;
    httpResp.read = function() {
      var chunk;
      if (data.length > 0) {
        chunk = data.shift();
        if (chunk === null) {
          return null;
        } else {
          return new Buffer(chunk);
        }
      } else {
        return null;
      }
    };
    cb(httpResp);
    AWS.util.arrayEach(data.slice(), function(str) {
      if (httpResp._events.readable) {
        return httpResp.emit('readable');
      } else {
        return httpResp.emit('data', new Buffer(str));
      }
    });
    return httpResp.emit('end');
  };

  mockHttpResponse = function(status, headers, data) {
    var stream;
    stream = new EventEmitter();
    spyOn(AWS.HttpClient, 'getInstance');
    AWS.HttpClient.getInstance.andReturn({
      handleRequest: function(req, opts, cb, errCb) {
        if (typeof status === 'number') {
          return mockHttpSuccessfulResponse(status, headers, data, cb);
        } else {
          return errCb(status);
        }
      }
    });
    return stream;
  };

  mockIntermittentFailureResponse = function(numFailures, status, headers, data) {
    var retryCount;
    retryCount = 0;
    spyOn(AWS.HttpClient, 'getInstance');
    return AWS.HttpClient.getInstance.andReturn({
      handleRequest: function(req, opts, cb, errCb) {
        var statusCode, _ref;
        if (retryCount < numFailures) {
          retryCount += 1;
          return errCb({
            code: 'NetworkingError',
            message: 'FAIL!'
          });
        } else {
          statusCode = (_ref = retryCount < numFailures) != null ? _ref : {
            500: status
          };
          return mockHttpSuccessfulResponse(statusCode, headers, data, cb);
        }
      }
    });
  };

  module.exports = {
    AWS: AWS,
    matchXML: matchXML,
    mockHttpResponse: mockHttpResponse,
    mockIntermittentFailureResponse: mockIntermittentFailureResponse,
    mockHttpSuccessfulResponse: mockHttpSuccessfulResponse,
    MockService: MockService
  };

}).call(this);

//# sourceMappingURL=helpers.map
