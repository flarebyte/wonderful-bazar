// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, EventEmitter, MockService, helpers;

  helpers = require('./helpers');

  EventEmitter = require('events').EventEmitter;

  AWS = helpers.AWS;

  MockService = helpers.MockService;

  describe('AWS.Request', function() {
    var service;
    service = new MockService;
    return describe('createReadStream', function() {
      it('streams data', function() {
        var data, done;
        data = '';
        done = false;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
        runs(function() {
          var request, s;
          request = service.makeRequest('mockMethod');
          s = request.createReadStream();
          s.on('end', function() {
            return done = true;
          });
          return s.on('data', function(c) {
            return data += c.toString();
          });
        });
        waitsFor(function() {
          return done === true;
        });
        return runs(function() {
          return expect(data).toEqual('FOOBARBAZQUX');
        });
      });
      it('streams2 data (readable event)', function() {
        var data, done;
        if (AWS.HttpClient.streamsApiVersion < 2) {
          return;
        }
        data = '';
        done = false;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
        runs(function() {
          var request, s;
          request = service.makeRequest('mockMethod');
          s = request.createReadStream();
          s.on('end', function() {
            return done = true;
          });
          return s.on('readable', function() {
            var chunk, e;
            try {
              chunk = s.read();
              if (chunk) {
                return data += chunk;
              }
            } catch (_error) {
              e = _error;
              return console.log(e.stack);
            }
          });
        });
        waitsFor(function() {
          return done === true;
        });
        return runs(function() {
          return expect(data).toEqual('FOOBARBAZQUX');
        });
      });
      it('streams2 data does not hang out while waiting response', function() {
        var data, done;
        if (AWS.HttpClient.streamsApiVersion < 2) {
          return;
        }
        data = '';
        done = false;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', null, null, 'BAZ', 'QUX']);
        runs(function() {
          var request, s;
          request = service.makeRequest('mockMethod');
          s = request.createReadStream();
          s.on('end', function() {
            return done = true;
          });
          return s.on('readable', function() {
            var chunk, e;
            try {
              chunk = s.read();
              if (chunk) {
                return data += chunk;
              }
            } catch (_error) {
              e = _error;
              return console.log(e.stack);
            }
          });
        });
        waitsFor(function() {
          return done === true;
        });
        return runs(function() {
          return expect(data).toEqual('FOOBARBAZQUX');
        });
      });
      it('does not stream data on failures', function() {
        var data, done, error;
        data = '';
        error = null;
        done = false;
        helpers.mockHttpResponse(404, {}, ['No such file']);
        runs(function() {
          var request, s;
          request = service.makeRequest('mockMethod');
          s = request.createReadStream();
          s.on('end', function() {
            return done = true;
          });
          s.on('error', function(e) {
            error = e;
            return done = true;
          });
          return s.on('data', function(c) {
            return data += c.toString();
          });
        });
        waitsFor(function() {
          return done === true;
        });
        return runs(function() {
          expect(data).toEqual('');
          return expect(error.statusCode).toEqual(404);
        });
      });
      it('retries temporal errors and streams resulting successful response', function() {
        var data, done, error;
        data = '';
        error = null;
        done = false;
        helpers.mockIntermittentFailureResponse(2, 200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
        runs(function() {
          var request, s;
          request = service.makeRequest('mockMethod');
          s = request.createReadStream();
          s.on('end', function() {
            return done = true;
          });
          s.on('error', function(e) {
            error = e;
            return done = true;
          });
          return s.on('data', function(c) {
            return data += c.toString();
          });
        });
        waitsFor(function() {
          return done === true;
        });
        return runs(function() {
          expect(data).toEqual('FOOBARBAZQUX');
          return expect(error).toEqual(null);
        });
      });
      it('streams partial data and raises an error', function() {
        var data, done, error, reqError;
        data = '';
        error = null;
        reqError = null;
        done = false;
        spyOn(AWS.HttpClient, 'getInstance');
        AWS.HttpClient.getInstance.andReturn({
          handleRequest: function(req, opts, cb, errCb) {
            req = new EventEmitter();
            req.statusCode = 200;
            req.headers = {};
            cb(req);
            AWS.util.arrayEach(['FOO', 'BAR', 'BAZ'], function(str) {
              return req.emit('data', new Buffer(str));
            });
            return errCb(new Error('fail'));
          }
        });
        runs(function() {
          var request, s;
          request = service.makeRequest('mockMethod');
          request.on('error', function(e) {
            return reqError = e;
          });
          request.on('complete', function() {
            return done = true;
          });
          s = request.createReadStream();
          s.on('error', function(e) {
            return error = e;
          });
          return s.on('data', function(c) {
            return data += c.toString();
          });
        });
        waitsFor(function() {
          return done === true;
        });
        return runs(function() {
          expect(data).toEqual('FOOBARBAZ');
          expect(error.message).toEqual('fail');
          return expect(reqError.message).toEqual('fail');
        });
      });
      return it('fails if retry occurs in the middle of a failing stream', function() {
        var data, error, reqError, resp, retryCount;
        data = '';
        error = null;
        reqError = null;
        resp = null;
        retryCount = 0;
        spyOn(AWS.HttpClient, 'getInstance');
        AWS.HttpClient.getInstance.andReturn({
          handleRequest: function(req, opts, cb, errCb) {
            req = new EventEmitter();
            req.statusCode = 200;
            req.headers = {};
            return process.nextTick(function() {
              cb(req);
              AWS.util.arrayEach(['FOO', 'BAR', 'BAZ', 'QUX'], function(str) {
                if (str === 'BAZ' && retryCount < 1) {
                  process.nextTick(function() {
                    retryCount += 1;
                    return errCb({
                      code: 'NetworkingError',
                      message: 'FAIL!',
                      retryable: true
                    });
                  });
                  return AWS.util.abort;
                } else {
                  return process.nextTick(function() {
                    return req.emit('data', new Buffer(str));
                  });
                }
              });
              if (retryCount >= 1) {
                return process.nextTick(function() {
                  return req.emit('end');
                });
              }
            });
          }
        });
        runs(function() {
          var request, s;
          request = service.makeRequest('mockMethod');
          request.on('error', function(e) {
            return reqError = e;
          });
          request.on('complete', function(r) {
            return resp = r;
          });
          s = request.createReadStream();
          s.on('error', function(e) {
            return error = e;
          });
          return s.on('data', function(c) {
            return data += c.toString();
          });
        });
        waitsFor(function() {
          return resp !== null;
        });
        return runs(function() {
          expect(data).toEqual('FOOBAR');
          expect(error.code).toEqual('NetworkingError');
          expect(reqError.code).toEqual('NetworkingError');
          return expect(resp.retryCount).toEqual(0);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=request.spec.map
