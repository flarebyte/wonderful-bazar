// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, helpers;

  helpers = require('./helpers');

  AWS = helpers.AWS;

  describe('AWS.SequentialExecutor', function() {
    beforeEach(function() {
      return this.emitter = new AWS.SequentialExecutor();
    });
    describe('addListeners', function() {
      it('accepts a hash of events and functions', function() {
        var listeners, triggers;
        triggers = [0, 0, 0];
        listeners = {
          eventName: {
            ConstantName1: function() {
              return triggers[0] = 1;
            },
            ConstantName2: function() {
              return triggers[1] = 1;
            }
          },
          otherEventName: {
            ConstantName3: function() {
              return triggers[2] = 1;
            }
          }
        };
        this.emitter.addListeners(listeners);
        expect(triggers).toEqual([0, 0, 0]);
        this.emitter.emit('eventName');
        expect(triggers).toEqual([1, 1, 0]);
        this.emitter.emit('otherEventName');
        return expect(triggers).toEqual([1, 1, 1]);
      });
      return it('accepts a SequentialExecutor object', function() {
        var listeners, triggers;
        triggers = [0, 0, 0];
        listeners = new AWS.SequentialExecutor();
        listeners.on('eventName', function() {
          return triggers[0] = 1;
        });
        listeners.on('eventName', function() {
          return triggers[1] = 1;
        });
        listeners.on('otherEventName', function() {
          return triggers[2] = 1;
        });
        this.emitter.addListeners(listeners);
        expect(triggers).toEqual([0, 0, 0]);
        this.emitter.emit('eventName');
        expect(triggers).toEqual([1, 1, 0]);
        this.emitter.emit('otherEventName');
        return expect(triggers).toEqual([1, 1, 1]);
      });
    });
    describe('addNamedListener', function() {
      it('defines a constant with the callback', function() {
        var spy;
        spy = createSpy();
        this.emitter.addNamedListener('CONSTNAME', 'eventName', spy);
        expect(this.emitter.CONSTNAME).toBe(spy);
        this.emitter.emit('eventName', ['argument']);
        return expect(spy).toHaveBeenCalledWith('argument');
      });
      return it('is chainable', function() {
        var r;
        r = this.emitter.addNamedListener('CONSTNAME', 'eventName', function() {});
        return expect(r).toBe(this.emitter);
      });
    });
    describe('addNamedListeners', function() {
      it('is chainable', function() {
        var r;
        r = this.emitter.addNamedListeners(function() {});
        return expect(r).toBe(this.emitter);
      });
      return it('provides an add function in callback to call addNamedListener', function() {
        var spy1, spy2;
        spy1 = createSpy();
        spy2 = createSpy();
        this.emitter.addNamedListeners(function(add) {
          add('CONST1', 'event1', spy1);
          return add('CONST2', 'event2', spy2);
        });
        expect(this.emitter.CONST1).toBe(spy1);
        expect(this.emitter.CONST2).toBe(spy2);
        this.emitter.emit('event1', ['arg1']);
        this.emitter.emit('event2', ['arg2']);
        expect(spy1).toHaveBeenCalledWith('arg1');
        return expect(spy2).toHaveBeenCalledWith('arg2');
      });
    });
    return describe('domain support', function() {
      var domain;
      domain = null;
      beforeEach(function() {
        return domain = require('domain').create();
      });
      afterEach(function() {
        return domain.dispose();
      });
      return it('supports domains', function() {
        var thrown;
        helpers.mockHttpResponse(200, {}, 'Success!');
        thrown = null;
        domain.on('error', function(err) {
          return thrown = err;
        });
        domain.run(function() {
          var service;
          service = new MockService();
          return service.makeRequest('operationName', function() {
            throw 'ERROR';
          });
        });
        return expect(thrown).toEqual('ERROR');
      });
    });
  });

}).call(this);

//# sourceMappingURL=sequential_executor.spec.map
