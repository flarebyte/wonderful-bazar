// Generated by CoffeeScript 1.7.1
(function() {
  var AWS;

  AWS = require('../../lib/core');

  require('../../lib/service_interface/rest');

  describe('AWS.ServiceInterface.Rest', function() {
    var MockRESTService, operation, request, response, svc;
    MockRESTService = AWS.util.inherit(AWS.Service, {
      endpointPrefix: 'mockservice'
    });
    operation = null;
    request = null;
    response = null;
    svc = eval(this.description);
    beforeEach(function() {
      var service;
      MockRESTService.prototype.api = {
        operations: {
          sampleOperation: {
            http: {
              method: 'POST',
              uri: '/'
            },
            input: null,
            output: null
          }
        }
      };
      AWS.Service.defineMethods(MockRESTService);
      operation = MockRESTService.prototype.api.operations.sampleOperation;
      service = new MockRESTService({
        region: 'region'
      });
      request = new AWS.Request(service, 'sampleOperation');
      return response = new AWS.Response(request);
    });
    describe('buildRequest', function() {
      var buildRequest;
      buildRequest = function(callback) {
        if (callback) {
          callback();
        }
        return svc.buildRequest(request);
      };
      describe('method', function() {
        return it('populates method from the operation', function() {
          buildRequest(function() {
            return operation.http.method = 'GET';
          });
          return expect(request.httpRequest.method).toEqual('GET');
        });
      });
      describe('uri', function() {
        it('populates uri from the operation', function() {
          buildRequest(function() {
            return operation.http.uri = '/path';
          });
          return expect(request.httpRequest.path).toEqual('/path');
        });
        it('replaces param placeholders', function() {
          buildRequest(function() {
            operation.http.uri = '/Owner/{Id}';
            operation.input = {
              members: {
                Id: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Id: 'abc'
            };
          });
          return expect(request.httpRequest.path).toEqual('/Owner/abc');
        });
        it('can replace multiple path placeholders', function() {
          buildRequest(function() {
            operation.http.uri = '/{Id}/{Count}';
            operation.input = {
              members: {
                Id: {
                  location: 'uri'
                },
                Count: {
                  ttype: 'integer',
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Id: 'abc',
              Count: 123
            };
          });
          return expect(request.httpRequest.path).toEqual('/abc/123');
        });
        it('performs querystring param replacements', function() {
          buildRequest(function() {
            operation.http.uri = '/path?id-param={Id}';
            operation.input = {
              members: {
                Id: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Id: 'abc'
            };
          });
          return expect(request.httpRequest.path).toEqual('/path?id-param=abc');
        });
        it('omits querystring when param is not provided', function() {
          buildRequest(function() {
            operation.http.uri = '/path?id-param={Id}';
            return operation.input = {
              members: {
                Id: {
                  location: 'uri'
                }
              }
            };
          });
          return expect(request.httpRequest.path).toEqual('/path');
        });
        it('accpets multiple query params with uri params', function() {
          buildRequest(function() {
            operation.http.uri = '/{Abc}/{Xyz}?foo={Foo}&bar={Bar}';
            operation.input = {
              members: {
                Abc: {
                  location: 'uri'
                },
                Xyz: {
                  location: 'uri'
                },
                Foo: {
                  location: 'uri'
                },
                Bar: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Abc: 'abc',
              Xyz: 'xyz',
              Bar: 'bar'
            };
          });
          return expect(request.httpRequest.path).toEqual('/abc/xyz?bar=bar');
        });
        return it('uri escapes params in both path and querystring', function() {
          buildRequest(function() {
            operation.http.uri = '/{Path}?query={Query}';
            operation.input = {
              members: {
                Path: {
                  location: 'uri'
                },
                Query: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Path: 'a b',
              Query: 'a/b'
            };
          });
          return expect(request.httpRequest.path).toEqual('/a%20b?query=a%2Fb');
        });
      });
      return describe('headers', function() {
        it('populates the headers with present params', function() {
          buildRequest(function() {
            operation.input = {
              members: {
                ACL: {
                  location: 'header',
                  name: 'x-amz-acl'
                }
              }
            };
            return request.params = {
              ACL: 'public-read'
            };
          });
          return expect(request.httpRequest.headers['x-amz-acl']).toEqual('public-read');
        });
        it('uses default rule name if .n property is not present', function() {
          buildRequest(function() {
            operation.input = {
              members: {
                ACL: {
                  location: 'header'
                }
              }
            };
            return request.params = {
              ACL: 'public-read'
            };
          });
          return expect(request.httpRequest.headers['ACL']).toEqual('public-read');
        });
        return it('works with map types', function() {
          buildRequest(function() {
            operation.input = {
              members: {
                Metadata: {
                  type: 'map',
                  location: 'header',
                  name: 'x-amz-meta-'
                }
              }
            };
            return request.params = {
              Metadata: {
                foo: 'bar',
                abc: 'xyz'
              }
            };
          });
          expect(request.httpRequest.headers['x-amz-meta-foo']).toEqual('bar');
          return expect(request.httpRequest.headers['x-amz-meta-abc']).toEqual('xyz');
        });
      });
    });
    return describe('extractData', function() {
      var extractData;
      extractData = function(callback) {
        if (callback) {
          callback();
        }
        return svc.extractData(response);
      };
      describe('headers', function() {
        it('extracts header values', function() {
          extractData(function() {
            operation.output = {
              type: 'structure',
              members: {
                ContentType: {
                  type: 'string',
                  location: 'header',
                  name: 'content-type'
                }
              }
            };
            return response.httpResponse.headers['content-type'] = 'text/plain';
          });
          return expect(response.data.ContentType).toEqual('text/plain');
        });
        it('extracts headers when the rule name is camel-cased', function() {
          extractData(function() {
            operation.output = {
              type: 'structure',
              members: {
                ContentType: {
                  type: 'string',
                  location: 'header',
                  name: 'Content-Type'
                }
              }
            };
            return response.httpResponse.headers['content-type'] = 'text/plain';
          });
          return expect(response.data.ContentType).toEqual('text/plain');
        });
        it('extracts headers when the header name is camel-cased', function() {
          extractData(function() {
            operation.output = {
              type: 'structure',
              members: {
                ContentType: {
                  type: 'string',
                  location: 'header',
                  name: 'content-type'
                }
              }
            };
            return response.httpResponse.headers['Content-Type'] = 'text/plain';
          });
          return expect(response.data.ContentType).toEqual('text/plain');
        });
        it('extracts map types from header', function() {
          extractData(function() {
            operation.output = {
              type: 'structure',
              members: {
                Metadata: {
                  type: 'map',
                  location: 'header',
                  name: 'x-amz-meta-'
                }
              }
            };
            response.httpResponse.headers['X-AMZ-META-FOO'] = 'foo';
            return response.httpResponse.headers['x-amz-meta-bar'] = 'bar';
          });
          expect(response.data.Metadata.FOO).toEqual('foo');
          return expect(response.data.Metadata.bar).toEqual('bar');
        });
        return it('adds empty map if no matching headers are found', function() {
          extractData(function() {
            return operation.output = {
              type: 'structure',
              members: {
                Metadata: {
                  type: 'map',
                  location: 'header',
                  name: 'x-amz-meta-'
                }
              }
            };
          });
          return expect(response.data.Metadata).toEqual({});
        });
      });
      return describe('status code', function() {
        it('extracts the http status when instructed to', function() {
          extractData(function() {
            operation.output = {
              type: 'structure',
              members: {
                Result: {
                  type: 'integer',
                  location: 'status'
                }
              }
            };
            return response.httpResponse.statusCode = 200;
          });
          return expect(response.data.Result).toEqual(200);
        });
        return it('casts string status codes to integers', function() {
          extractData(function() {
            operation.output = {
              type: 'structure',
              members: {
                Result: {
                  type: 'integer',
                  location: 'status'
                }
              }
            };
            return response.httpResponse.statusCode = '202';
          });
          return expect(response.data.Result).toEqual(202);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=rest.spec.map
