// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, helpers;

  helpers = require('../helpers');

  AWS = helpers.AWS;

  require('../../lib/service_interface/rest_json');

  describe('AWS.ServiceInterface.RestJson', function() {
    var MockJSONRESTService, operation, request, response, svc;
    MockJSONRESTService = AWS.util.inherit(AWS.Service, {
      endpointPrefix: 'mockservice'
    });
    operation = null;
    request = null;
    response = null;
    svc = eval(this.description);
    beforeEach(function() {
      var service;
      MockJSONRESTService.prototype.api = {
        operations: {
          sampleOperation: {
            http: {
              method: 'POST',
              uri: '/'
            },
            input: {
              type: 'structure',
              members: {}
            },
            output: {
              type: 'structure',
              members: {}
            }
          }
        }
      };
      AWS.Service.defineMethods(MockJSONRESTService);
      operation = MockJSONRESTService.prototype.api.operations.sampleOperation;
      service = new MockJSONRESTService({
        region: 'region'
      });
      request = new AWS.Request(service, 'sampleOperation');
      return response = new AWS.Response(request);
    });
    describe('buildRequest', function() {
      var buildRequest;
      buildRequest = function(callback) {
        if (callback) {
          callback();
        }
        return svc.buildRequest(request);
      };
      describe('method', function() {
        return it('populates method from the operation', function() {
          buildRequest(function() {
            return operation.http.method = 'GET';
          });
          return expect(request.httpRequest.method).toEqual('GET');
        });
      });
      describe('uri', function() {
        it('populates uri from the operation', function() {
          buildRequest(function() {
            return operation.http.uri = '/path';
          });
          return expect(request.httpRequest.path).toEqual('/path');
        });
        it('replaces param placeholders', function() {
          buildRequest(function() {
            operation.http.uri = '/Owner/{Id}';
            operation.input = {
              members: {
                Id: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Id: 'abc'
            };
          });
          return expect(request.httpRequest.path).toEqual('/Owner/abc');
        });
        it('can replace multiple path placeholders', function() {
          buildRequest(function() {
            operation.http.uri = '/{Id}/{Count}';
            operation.input = {
              members: {
                Id: {
                  location: 'uri'
                },
                Count: {
                  type: 'integer',
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Id: 'abc',
              Count: 123
            };
          });
          return expect(request.httpRequest.path).toEqual('/abc/123');
        });
        it('performs querystring param replacements', function() {
          buildRequest(function() {
            operation.http.uri = '/path?id-param={Id}';
            operation.input = {
              members: {
                Id: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Id: 'abc'
            };
          });
          return expect(request.httpRequest.path).toEqual('/path?id-param=abc');
        });
        it('omits querystring when param is not provided', function() {
          buildRequest(function() {
            operation.http.uri = '/path?id-param={Id}';
            return operation.input = {
              members: {
                Id: {
                  location: 'uri'
                }
              }
            };
          });
          return expect(request.httpRequest.path).toEqual('/path');
        });
        it('accpets multiple query params with uri params', function() {
          buildRequest(function() {
            operation.http.uri = '/{Abc}/{Xyz}?foo={Foo}&bar={Bar}';
            operation.input = {
              members: {
                Abc: {
                  location: 'uri'
                },
                Xyz: {
                  location: 'uri'
                },
                Foo: {
                  location: 'uri'
                },
                Bar: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Abc: 'abc',
              Xyz: 'xyz',
              Bar: 'bar'
            };
          });
          return expect(request.httpRequest.path).toEqual('/abc/xyz?bar=bar');
        });
        return it('uri escapes params in both path and querystring', function() {
          buildRequest(function() {
            operation.http.uri = '/{Path}?query={Query}';
            operation.input = {
              members: {
                Path: {
                  location: 'uri'
                },
                Query: {
                  location: 'uri'
                }
              }
            };
            return request.params = {
              Path: 'a b',
              Query: 'a/b'
            };
          });
          return expect(request.httpRequest.path).toEqual('/a%20b?query=a%2Fb');
        });
      });
      describe('headers', function() {
        it('populates the headers with present params', function() {
          buildRequest(function() {
            operation.input = {
              members: {
                ACL: {
                  location: 'header',
                  name: 'x-amz-acl'
                }
              }
            };
            return request.params = {
              ACL: 'public-read'
            };
          });
          return expect(request.httpRequest.headers['x-amz-acl']).toEqual('public-read');
        });
        it('uses default rule name if .n property is not present', function() {
          buildRequest(function() {
            operation.input = {
              members: {
                ACL: {
                  location: 'header'
                }
              }
            };
            return request.params = {
              ACL: 'public-read'
            };
          });
          return expect(request.httpRequest.headers['ACL']).toEqual('public-read');
        });
        return it('works with map types', function() {
          buildRequest(function() {
            operation.input = {
              members: {
                Metadata: {
                  type: 'map',
                  location: 'header',
                  name: 'x-amz-meta-'
                }
              }
            };
            return request.params = {
              Metadata: {
                foo: 'bar',
                abc: 'xyz'
              }
            };
          });
          expect(request.httpRequest.headers['x-amz-meta-foo']).toEqual('bar');
          return expect(request.httpRequest.headers['x-amz-meta-abc']).toEqual('xyz');
        });
      });
      return describe('body', function() {
        it('builds root element if rules contains root', function() {
          buildRequest(function() {
            operation.input = {
              payload: 'Config',
              members: {
                Config: {
                  type: 'structure',
                  members: {
                    Name: {
                      type: 'string'
                    },
                    Type: {
                      type: 'string'
                    }
                  }
                }
              }
            };
            return request.params = {
              Config: {
                Name: 'foo',
                Type: 'bar'
              }
            };
          });
          return expect(request.httpRequest.body.toString()).toEqual('{"Name":"foo","Type":"bar"}');
        });
        return it('builds payload element as non JSON data if rules contains payload', function() {
          buildRequest(function() {
            operation.input = {
              payload: 'Body',
              members: {
                Body: {
                  type: 'binary',
                  location: 'body'
                }
              }
            };
            return request.params = {
              Body: 'foobar'
            };
          });
          return expect(request.httpRequest.body).toEqual('foobar');
        });
      });
    });
    describe('extractError', function() {
      var extractError;
      extractError = function(body) {
        response.httpResponse.statusCode = 500;
        response.httpResponse.body = new Buffer(body);
        return svc.extractError(response);
      };
      it('removes prefixes from the error code', function() {
        extractError('{"__type":"com.amazon.coral.service#ErrorCode" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual('ErrorCode');
        return expect(response.data).toEqual(null);
      });
      it('returns the full code when a # is not present', function() {
        extractError('{"__type":"ErrorCode" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual('ErrorCode');
        return expect(response.data).toEqual(null);
      });
      it('returns the status code when the body is blank', function() {
        extractError('');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual(500);
        expect(response.error.message).toEqual(null);
        return expect(response.data).toEqual(null);
      });
      it('returns null for the message when not present', function() {
        extractError('{"__type":"ErrorCode" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual(null);
        return expect(response.data).toEqual(null);
      });
      it('returns the message when present', function() {
        extractError('{"__type":"ErrorCode", "message":"Error Message" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual('Error Message');
        return expect(response.data).toEqual(null);
      });
      it('returns the message when the message property is upper-cased', function() {
        extractError('{"__type":"ErrorCode", "Message":"Error Message" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual('Error Message');
        return expect(response.data).toEqual(null);
      });
      return it('returns a special message for RequestEntityToLarge errors', function() {
        extractError('{"__type":"RequestEntityTooLarge" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual('Request body must be less than 1 MB');
        return expect(response.data).toEqual(null);
      });
    });
    return describe('extractData', function() {
      var extractData;
      extractData = function(body) {
        response.httpResponse.statusCode = 200;
        response.httpResponse.body = new Buffer(body);
        return svc.extractData(response);
      };
      it('JSON parses http response bodies', function() {
        extractData('{"a":1, "b":"xyz"}');
        expect(response.error).toEqual(null);
        return expect(response.data).toEqual({
          a: 1,
          b: 'xyz'
        });
      });
      it('pulls header data out of response', function() {
        response.httpResponse.headers['x-title'] = 'The title';
        operation.output = {
          type: 'structure',
          members: {
            Title: {
              location: 'header',
              name: 'x-title'
            }
          }
        };
        extractData('{}');
        expect(response.error).toEqual(null);
        return expect(response.data.Title).toEqual('The title');
      });
      it('pulls body out into data key if body is payload', function() {
        operation.output = {
          type: 'structure',
          payload: 'Body',
          members: {
            Body: {
              location: 'body',
              type: 'binary'
            }
          }
        };
        extractData('foobar');
        expect(response.error).toEqual(null);
        return expect(response.data.Body).toEqual('foobar');
      });
      it('pulls body out as Buffer if body is streaming payload', function() {
        operation.output = {
          type: 'structure',
          payload: 'Body',
          members: {
            Body: {
              location: 'body',
              type: 'binary',
              streaming: true
            }
          }
        };
        extractData('foobar');
        expect(response.error).toEqual(null);
        expect(response.data.Body instanceof Buffer).toEqual(true);
        return expect(response.data.Body.toString()).toEqual('foobar');
      });
      it('returns an empty object when the body is an empty string', function() {
        extractData('');
        expect(response.error).toEqual(null);
        return expect(response.data).toEqual({});
      });
      return it('returns an empty object when the body is null', function() {
        extractData('');
        expect(response.error).toEqual(null);
        return expect(response.data).toEqual({});
      });
    });
  });

}).call(this);

//# sourceMappingURL=rest_json.spec.map
