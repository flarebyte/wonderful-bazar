// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, helpers;

  helpers = require('../helpers');

  AWS = helpers.AWS;

  require('../../lib/service_interface/rest_xml');

  describe('AWS.ServiceInterface.RestXml', function() {
    var MockRESTXMLService, operation, request, response, svc, xmlns;
    MockRESTXMLService = AWS.util.inherit(AWS.Service, {
      endpointPrefix: 'mockservice'
    });
    xmlns = 'http://mockservice.com/xmlns';
    operation = null;
    request = null;
    response = null;
    svc = eval(this.description);
    beforeEach(function() {
      var service;
      MockRESTXMLService.prototype.api = {
        xmlnamespace: xmlns,
        operations: {
          sampleOperation: {
            http: {
              method: 'POST',
              uri: '/'
            },
            input: {
              type: 'structure',
              members: {}
            },
            output: {
              type: 'structure',
              members: {}
            }
          }
        }
      };
      AWS.Service.defineMethods(MockRESTXMLService);
      operation = MockRESTXMLService.prototype.api.operations.sampleOperation;
      service = new MockRESTXMLService({
        region: 'region'
      });
      request = new AWS.Request(service, 'sampleOperation');
      return response = new AWS.Response(request);
    });
    describe('buildRequest', function() {
      var buildRequest;
      buildRequest = function(callback) {
        if (callback) {
          callback();
        }
        return svc.buildRequest(request);
      };
      describe('empty bodies', function() {
        it('defaults body to empty string when there are no inputs', function() {
          buildRequest(function() {
            return operation.input = {
              type: 'structure',
              members: {}
            };
          });
          return expect(request.httpRequest.body).toEqual('');
        });
        return it('defaults body to empty string when no body params are present', function() {
          buildRequest(function() {
            operation.http.uri = '/{Bucket}';
            operation.input = {
              members: {
                Bucket: {
                  location: 'uri',
                  required: true
                },
                ACL: {
                  name: 'x-amz-acl',
                  location: 'header'
                }
              }
            };
            return request.params = {
              Bucket: 'abc',
              ACL: 'canned-acl'
            };
          });
          expect(request.httpRequest.body).toEqual('');
          expect(request.httpRequest.path).toEqual('/abc');
          return expect(request.httpRequest.headers['x-amz-acl']).toEqual('canned-acl');
        });
      });
      describe('string bodies', function() {
        return it('populates the body with string types directly', function() {
          buildRequest(function() {
            operation.http.uri = '/{Bucket}';
            operation.input = {
              payload: 'Data',
              members: {
                Bucket: {
                  location: 'uri',
                  required: true
                },
                Data: {
                  type: 'string'
                }
              }
            };
            return request.params = {
              Bucket: 'bucket-name',
              Data: 'abc'
            };
          });
          return expect(request.httpRequest.body).toEqual('abc');
        });
      });
      return describe('xml bodies', function() {
        it('populates the body with XML from the params', function() {
          var xml;
          buildRequest(function() {
            operation.http.uri = '/{Bucket}?next-marker={Marker}&limit={Limit}';
            operation.input = {
              payload: 'Config',
              members: {
                Bucket: {
                  type: 'string',
                  location: 'uri',
                  required: true
                },
                Marker: {
                  type: 'string',
                  location: 'uri'
                },
                Limit: {
                  type: 'integer',
                  location: 'uri'
                },
                ACL: {
                  type: 'string',
                  location: 'header',
                  name: 'x-amz-acl'
                },
                Metadata: {
                  type: 'map',
                  location: 'header',
                  name: 'x-amz-meta-'
                },
                Config: {
                  type: 'structure',
                  required: true,
                  members: {
                    Abc: {},
                    Locations: {
                      type: 'list',
                      members: {
                        type: 'string',
                        name: 'Location'
                      }
                    },
                    Data: {
                      type: 'list',
                      members: {
                        type: 'structure',
                        members: {
                          Foo: {},
                          Bar: {}
                        }
                      }
                    }
                  }
                }
              }
            };
            return request.params = {
              ACL: 'canned-acl',
              Config: {
                Abc: 'abc',
                Locations: ['a', 'b', 'c'],
                Data: [
                  {
                    Foo: 'foo1',
                    Bar: 'bar1'
                  }, {
                    Foo: 'foo2',
                    Bar: 'bar2'
                  }
                ]
              },
              Bucket: 'bucket-name',
              Marker: 'marker',
              Limit: 123,
              Metadata: {
                abc: 'xyz',
                mno: 'hjk'
              }
            };
          });
          xml = "<Config xmlns=\"http://mockservice.com/xmlns\">\n  <Abc>abc</Abc>\n  <Locations>\n    <Location>a</Location>\n    <Location>b</Location>\n    <Location>c</Location>\n  </Locations>\n  <Data>\n    <member>\n      <Foo>foo1</Foo>\n      <Bar>bar1</Bar>\n    </member>\n    <member>\n      <Foo>foo2</Foo>\n      <Bar>bar2</Bar>\n    </member>\n  </Data>\n</Config>";
          expect(request.httpRequest.method).toEqual('POST');
          expect(request.httpRequest.path).toEqual('/bucket-name?next-marker=marker&limit=123');
          expect(request.httpRequest.headers['x-amz-acl']).toEqual('canned-acl');
          expect(request.httpRequest.headers['x-amz-meta-abc']).toEqual('xyz');
          expect(request.httpRequest.headers['x-amz-meta-mno']).toEqual('hjk');
          return helpers.matchXML(request.httpRequest.body, xml);
        });
        return it('omits the body xml when body params are not present', function() {
          buildRequest(function() {
            operation.http.uri = '/{Bucket}';
            operation.input = {
              members: {
                Bucket: {
                  location: 'uri',
                  required: true
                },
                Config: {}
              }
            };
            return request.params = {
              Bucket: 'abc'
            };
          });
          expect(request.httpRequest.body).toEqual('');
          return expect(request.httpRequest.path).toEqual('/abc');
        });
      });
    });
    describe('extractError', function() {
      var extractError;
      extractError = function(body) {
        if (body === void 0) {
          body = "<Error>\n  <Code>InvalidArgument</Code>\n  <Message>Provided param is bad</Message>\n</Error>";
        }
        response.httpResponse.statusCode = 400;
        response.httpResponse.body = new Buffer(body);
        return svc.extractError(response);
      };
      it('extracts the error code and message', function() {
        extractError();
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual('InvalidArgument');
        expect(response.error.message).toEqual('Provided param is bad');
        return expect(response.data).toEqual(null);
      });
      it('returns an empty error when the body is blank', function() {
        extractError('');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual(400);
        expect(response.error.message).toEqual(null);
        return expect(response.data).toEqual(null);
      });
      it('extracts error when inside <Errors>', function() {
        extractError("<SomeResponse>\n  <Errors>\n    <Error>\n      <Code>code</Code><Message>msg</Message>\n    </Error>\n  </Errors>\n</SomeResponse>");
        expect(response.error.code).toEqual('code');
        return expect(response.error.message).toEqual('msg');
      });
      return it('extracts error when <Error> is nested', function() {
        extractError("<SomeResponse>\n  <Error>\n    <Code>code</Code><Message>msg</Message>\n  </Error>\n</SomeResponse>");
        expect(response.error.code).toEqual('code');
        return expect(response.error.message).toEqual('msg');
      });
    });
    return describe('extractData', function() {
      var extractData;
      extractData = function(body) {
        response.httpResponse.statusCode = 200;
        response.httpResponse.body = new Buffer(body);
        return svc.extractData(response);
      };
      it('parses the xml body', function() {
        operation.output = {
          type: 'structure',
          members: {
            Foo: {},
            Bar: {
              type: 'list',
              members: {
                name: 'Item'
              }
            }
          }
        };
        extractData("<xml>\n  <Foo>foo</Foo>\n  <Bar>\n    <Item>a</Item>\n    <Item>b</Item>\n    <Item>c</Item>\n  </Bar>\n</xml>");
        return expect(response.data).toEqual({
          Foo: 'foo',
          Bar: ['a', 'b', 'c']
        });
      });
      it('sets payload element to a Buffer object when it streams', function() {
        operation.output = {
          type: 'structure',
          payload: 'Body',
          members: {
            Body: {
              streaming: true
            }
          }
        };
        extractData('Buffer data');
        expect(response.data.Body instanceof Buffer).toBeTruthy();
        return expect(response.data.Body.toString()).toEqual('Buffer data');
      });
      it('sets payload element to String when it does not stream', function() {
        operation.output = {
          type: 'structure',
          payload: 'Body',
          members: {
            Body: {}
          }
        };
        extractData('Buffer data');
        expect(typeof response.data.Body).toEqual('string');
        return expect(response.data.Body).toEqual('Buffer data');
      });
      return it('sets payload element along with other outputs', function() {
        response.httpResponse.headers['x-amz-foo'] = 'foo';
        response.httpResponse.headers['x-amz-bar'] = 'bar';
        operation.output = {
          type: 'structure',
          payload: 'Baz',
          members: {
            Foo: {
              location: 'header',
              name: 'x-amz-foo'
            },
            Bar: {
              location: 'header',
              name: 'x-amz-bar'
            },
            Baz: {}
          }
        };
        extractData('Buffer data');
        expect(response.data.Foo).toEqual('foo');
        expect(response.data.Bar).toEqual('bar');
        return expect(response.data.Baz).toEqual('Buffer data');
      });
    });
  });

}).call(this);

//# sourceMappingURL=rest_xml.spec.map
