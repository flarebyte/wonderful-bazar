// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, helpers;

  helpers = require('../helpers');

  AWS = helpers.AWS;

  describe('AWS.XML.Parser', function() {
    var parse;
    parse = function(xml, rules, callback) {
      return callback.call(this, new AWS.XML.Parser(rules).parse(xml));
    };
    describe('default behavior', function() {
      var rules;
      rules = {};
      it('returns an empty object from an empty document', function() {
        var xml;
        xml = '<xml/>';
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({});
        });
      });
      it('returns empty elements as null', function() {
        var xml;
        xml = '<xml><element/></xml>';
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            element: null
          });
        });
      });
      it('converts string elements to properties', function() {
        var xml;
        xml = '<xml><foo>abc</foo><bar>xyz</bar></xml>';
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            foo: 'abc',
            bar: 'xyz'
          });
        });
      });
      it('converts nested elements into objects', function() {
        var xml;
        xml = '<xml><foo><bar>yuck</bar></foo></xml>';
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            foo: {
              bar: 'yuck'
            }
          });
        });
      });
      it('returns everything as a string (even numbers)', function() {
        var xml;
        xml = '<xml><count>123</count></xml>';
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            count: '123'
          });
        });
      });
      it('flattens sibling elements of the same name', function() {
        var xml;
        xml = '<xml><foo><bar>1</bar><bar>2</bar></foo></xml>';
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            foo: {
              bar: '1'
            }
          });
        });
      });
      return it('ignores xmlns on the root element', function() {
        var xml;
        xml = '<xml xmlns="http://foo.bar.com"><Abc>xyz</Abc></xml>';
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            Abc: 'xyz'
          });
        });
      });
    });
    describe('structures', function() {
      return it('returns empty objects as {}', function() {
        var rules, xml;
        xml = '<xml><Item/></xml>';
        rules = {
          type: 'structure',
          members: {
            Item: {
              type: 'structure',
              members: {
                Name: {
                  type: 'string'
                }
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            Item: {}
          });
        });
      });
    });
    describe('lists', function() {
      it('returns empty lists as []', function() {
        var rules, xml;
        xml = '<xml><items/></xml>';
        rules = {
          type: 'structure',
          members: {
            items: {
              type: 'list',
              members: {
                type: 'string'
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            items: []
          });
        });
      });
      it('returns missing lists as []', function() {
        var rules, xml;
        xml = '<xml></xml>';
        rules = {
          type: 'structure',
          members: {
            items: {
              type: 'list',
              members: {
                type: 'string'
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            items: []
          });
        });
      });
      it('Converts xml lists of strings into arrays of strings', function() {
        var rules, xml;
        xml = "<xml>\n  <items>\n    <member>abc</member>\n    <member>xyz</member>\n  </items>\n</xml>";
        rules = {
          type: 'structure',
          members: {
            items: {
              type: 'list',
              members: {}
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            items: ['abc', 'xyz']
          });
        });
      });
      it('Observes list member names when present', function() {
        var rules, xml;
        xml = "<xml>\n  <items>\n    <item>abc</item>\n    <item>xyz</item>\n  </items>\n</xml>";
        rules = {
          type: 'structure',
          members: {
            items: {
              type: 'list',
              members: {
                name: 'item'
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            items: ['abc', 'xyz']
          });
        });
      });
      it('can parse lists of strucures', function() {
        var rules, xml;
        xml = "<xml>\n  <People>\n    <member><Name>abc</Name></member>>\n    <member><Name>xyz</Name></member>>\n  </People>\n</xml>";
        rules = {
          type: 'structure',
          members: {
            People: {
              type: 'list',
              members: {
                type: 'structure',
                members: {
                  Name: {
                    type: 'string'
                  }
                }
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            People: [
              {
                Name: 'abc'
              }, {
                Name: 'xyz'
              }
            ]
          });
        });
      });
      return it('can parse lists of strucures with renames', function() {
        var rules, xml;
        xml = "<xml>\n  <People>\n    <Person><Name>abc</Name></Person>>\n    <Person><Name>xyz</Name></Person>>\n  </People>\n</xml>";
        rules = {
          type: 'structure',
          members: {
            People: {
              type: 'list',
              members: {
                type: 'structure',
                name: 'Person',
                members: {
                  Name: {
                    type: 'string'
                  }
                }
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            People: [
              {
                Name: 'abc'
              }, {
                Name: 'xyz'
              }
            ]
          });
        });
      });
    });
    describe('flattened lists', function() {
      var xml;
      xml = "<xml>\n  <person>\n    <name>Unknown</name>\n    <alias>John Doe</alias>\n    <alias>Jane Doe</alias>\n  </person>\n</xml>";
      it('flattens siblings of the same name into a single element', function() {
        return parse(xml, {}, function(data) {
          return expect(data).toEqual({
            person: {
              name: 'Unknown',
              alias: 'John Doe'
            }
          });
        });
      });
      it('collects sibling elements of the same name', function() {
        var rules;
        rules = {
          type: 'structure',
          members: {
            person: {
              members: {
                alias: {
                  name: 'aka',
                  type: 'list',
                  flattened: true,
                  members: {}
                }
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            person: {
              name: 'Unknown',
              aka: ['John Doe', 'Jane Doe']
            }
          });
        });
      });
      it('flattened lists can be composed of complex obects', function() {
        var rules, values;
        xml = "<xml>\n  <name>Name</name>\n  <complexValue>\n    <a>1</a>\n    <b>2</b>\n  </complexValue>\n  <complexValue>\n    <a>3</a>\n    <b>4</b>\n  </complexValue>\n</xml>";
        rules = {
          type: 'structure',
          members: {
            complexValue: {
              type: 'list',
              flattened: true,
              name: 'values',
              members: {
                type: 'structure',
                members: {}
              }
            }
          }
        };
        values = {
          name: 'Name',
          values: [
            {
              a: '1',
              b: '2'
            }, {
              a: '3',
              b: '4'
            }
          ]
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual(values);
        });
      });
      return it('can parse flattened lists of complex objects', function() {
        var rules;
        xml = "<xml>\n  <Count>2</Count>\n  <Person><Name>abc</Name></Person>\n  <Person><Name>xyz</Name></Person>\n</xml>";
        rules = {
          type: 'structure',
          members: {
            Count: {
              type: 'integer'
            },
            Person: {
              type: 'list',
              flattened: true,
              name: 'People',
              members: {
                type: 'structure',
                name: 'Person'
              }
            }
          }
        };
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            Count: 2,
            People: [
              {
                Name: 'abc'
              }, {
                Name: 'xyz'
              }
            ]
          });
        });
      });
    });
    describe('maps', function() {
      return describe('non-flattened', function() {
        it('expects entry, key, and value elements by default', function() {
          var rules, xml;
          xml = "<xml>\n  <SummaryMap>\n    <entry>\n      <key>Groups</key>\n      <value>31</value>\n    </entry>\n    <entry>\n      <key>GroupsQuota</key>\n      <value>50</value>\n    </entry>\n    <entry>\n      <key>UsersQuota</key>\n      <value>150</value>\n    </entry>\n  </SummaryMap>\n</xml>";
          rules = {
            type: 'structure',
            members: {
              SummaryMap: {
                type: 'map',
                members: {
                  type: 'integer'
                }
              }
            }
          };
          return parse(xml, rules, function(data) {
            return expect(data).toEqual({
              SummaryMap: {
                Groups: 31,
                GroupsQuota: 50,
                UsersQuota: 150
              }
            });
          });
        });
        it('can use alternate names for key and value elements', function() {
          var rules, xml;
          xml = "<xml>\n  <SummaryMap>\n    <entry>\n      <Property>Groups</Property>\n      <Count>31</Count>\n    </entry>\n    <entry>\n      <Property>GroupsQuota</Property>\n      <Count>50</Count>\n    </entry>\n    <entry>\n      <Property>UsersQuota</Property>\n      <Count>150</Count>\n    </entry>\n  </SummaryMap>\n</xml>";
          rules = {
            type: 'structure',
            members: {
              SummaryMap: {
                type: 'map',
                name: 'Summary',
                keys: {
                  name: 'Property'
                },
                members: {
                  type: 'integer',
                  name: 'Count'
                }
              }
            }
          };
          return parse(xml, rules, function(data) {
            return expect(data).toEqual({
              Summary: {
                Groups: 31,
                GroupsQuota: 50,
                UsersQuota: 150
              }
            });
          });
        });
        return describe('flattened', function() {
          it('expects key and value elements by default', function() {
            var rules, xml;
            xml = "<xml>\n  <Attributes>\n    <key>color</key>\n    <value>red</value>\n  </Attributes>\n  <Attributes>\n    <key>size</key>\n    <value>large</value>\n  </Attributes>\n</xml>";
            rules = {
              type: 'strucure',
              members: {
                Attributes: {
                  type: 'map',
                  flattened: true
                }
              }
            };
            return parse(xml, rules, function(data) {
              return expect(data).toEqual({
                Attributes: {
                  color: 'red',
                  size: 'large'
                }
              });
            });
          });
          return it('can use alternate names for key and value elements', function() {
            var rules, xml;
            xml = "<xml>\n  <Attribute>\n    <AttrName>age</AttrName>\n    <AttrValue>35</AttrValue>\n  </Attribute>\n  <Attribute>\n    <AttrName>height</AttrName>\n    <AttrValue>72</AttrValue>\n  </Attribute>\n</xml>";
            rules = {
              type: 'structure',
              members: {
                Attribute: {
                  name: 'Attributes',
                  type: 'map',
                  flattened: true,
                  keys: {
                    name: 'AttrName'
                  },
                  members: {
                    name: 'AttrValue',
                    type: 'integer'
                  }
                }
              }
            };
            return parse(xml, rules, function(data) {
              return expect(data).toEqual({
                Attributes: {
                  age: 35,
                  height: 72
                }
              });
            });
          });
        });
      });
    });
    describe('booleans', function() {
      var rules;
      rules = {
        type: 'structure',
        members: {
          enabled: {
            type: 'boolean'
          }
        }
      };
      it('converts the string "true" in to the boolean value true', function() {
        var xml;
        xml = "<xml><enabled>true</enabled></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            enabled: true
          });
        });
      });
      it('converts the string "false" in to the boolean value false', function() {
        var xml;
        xml = "<xml><enabled>false</enabled></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            enabled: false
          });
        });
      });
      return it('converts the empty elements into null', function() {
        var xml;
        xml = "<xml><enabled/></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            enabled: null
          });
        });
      });
    });
    describe('timestamp', function() {
      var rules;
      rules = {
        type: 'structure',
        members: {
          CreatedAt: {
            type: 'timestamp'
          }
        }
      };
      it('returns an empty element as null', function() {
        var xml;
        xml = "<xml><CreatedAt/></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            CreatedAt: null
          });
        });
      });
      it('understands unix timestamps', function() {
        var date, timestamp, xml;
        timestamp = 1349908100;
        date = new Date(timestamp * 1000);
        xml = "<xml><CreatedAt>" + timestamp + "</CreatedAt></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            CreatedAt: date
          });
        });
      });
      it('understands basic iso8601 strings', function() {
        var date, timestamp, xml;
        timestamp = '2012-10-10T15:47:10.001Z';
        date = new Date(timestamp);
        xml = "<xml><CreatedAt>" + timestamp + "</CreatedAt></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            CreatedAt: date
          });
        });
      });
      it('understands basic rfc822 strings', function() {
        var date, timestamp, xml;
        timestamp = 'Wed, 10 Oct 2012 15:59:55 UTC';
        date = new Date(timestamp);
        xml = "<xml><CreatedAt>" + timestamp + "</CreatedAt></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            CreatedAt: date
          });
        });
      });
      return it('throws an error when unable to determine the format', function() {
        var error, message, timestamp, xml;
        timestamp = 'bad-date-format';
        xml = "<xml><CreatedAt>" + timestamp + "</CreatedAt></xml>";
        message = 'unhandled timestamp format: ' + timestamp;
        error = {
          code: 'AWS.XML.Parser.Error',
          message: message
        };
        return expect(function() {
          return new AWS.XML.Parser(rules).parse(xml);
        }).toThrow(error);
      });
    });
    describe('numbers', function() {
      var rules;
      rules = {
        type: 'structure',
        members: {
          decimal: {
            type: 'float'
          }
        }
      };
      it('float parses elements types as integer', function() {
        var xml;
        xml = "<xml><decimal>123.456</decimal></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            decimal: 123.456
          });
        });
      });
      return it('returns null for empty elements', function() {
        var xml;
        xml = "<xml><decimal/></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            decimal: null
          });
        });
      });
    });
    describe('integers', function() {
      var rules;
      rules = {
        type: 'structure',
        members: {
          count: {
            type: 'integer'
          }
        }
      };
      it('integer parses elements types as integer', function() {
        var xml;
        xml = "<xml><count>123</count></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            count: 123
          });
        });
      });
      return it('returns null for empty elements', function() {
        var xml;
        xml = "<xml><count/></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            count: null
          });
        });
      });
    });
    describe('renaming elements', function() {
      it('can rename scalar elements', function() {
        var rules, xml;
        rules = {
          type: 'structure',
          members: {
            alias: {
              name: 'aka'
            }
          }
        };
        xml = "<xml><alias>John Doe</alias></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            aka: 'John Doe'
          });
        });
      });
      return it('can rename nested elements', function() {
        var rules, xml;
        rules = {
          type: 'structure',
          members: {
            person: {
              members: {
                alias: {
                  name: 'aka'
                }
              }
            }
          }
        };
        xml = "<xml><person><name>Joe</name><alias>John Doe</alias></person></xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            person: {
              name: 'Joe',
              aka: 'John Doe'
            }
          });
        });
      });
    });
    describe('base64 encoded strings', function() {
      return it('base64 decodes string elements with encoding="base64"', function() {
        var rules, xml;
        rules = {
          type: 'structure',
          members: {
            Value: {
              type: 'string'
            }
          }
        };
        xml = "<xml>\n  <Value encoding=\"base64\">Zm9v</Value>\n</xml>";
        parse(xml, rules, function(data) {
          return expect(data).toEqual({
            Value: 'foo'
          });
        });
        rules = {
          type: 'structure',
          members: {
            Value: {}
          }
        };
        xml = "<xml>\n  <Value encoding=\"base64\">Zm9v</Value>\n</xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            Value: 'foo'
          });
        });
      });
    });
    describe('elements with XML namespaces', function() {
      return it('strips the xmlns element', function() {
        var rules, xml;
        rules = {
          type: 'structure',
          members: {
            List: {
              type: 'list',
              members: {
                type: 'structure',
                members: {
                  Attr1: {},
                  Attr2: {
                    type: 'structure',
                    members: {
                      Foo: {}
                    }
                  }
                }
              }
            }
          }
        };
        xml = "<xml xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  <List>\n    <member>\n      <Attr1 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"CanonicalUser\">abc</Attr1>\n      <Attr2 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"CanonicalUser\"><Foo>bar</Foo></Attr2>\n    </member>\n  </List>\n</xml>";
        return parse(xml, rules, function(data) {
          return expect(data).toEqual({
            List: [
              {
                Attr1: 'abc',
                Attr2: {
                  Foo: 'bar'
                }
              }
            ]
          });
        });
      });
    });
    return describe('parsing errors', function() {
      return it('throws an error when unable to parse the xml', function() {
        var error, message, rules, xml;
        xml = 'asdf';
        rules = {};
        message = "Non-whitespace before first tag.\nLine: 0\nColumn: 1\nChar: a";
        error = {
          code: 'AWS.XML.Parser.Error',
          message: message
        };
        return expect(function() {
          return new AWS.XML.Parser(rules).parse(xml);
        }).toThrow(error);
      });
    });
  });

}).call(this);

//# sourceMappingURL=parser.spec.map
